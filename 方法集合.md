# 方法目录 {ignore}

[toc]

## 1. 函数节流 (下方有另外的节流处理函数)

```ts
/** 函数节流
 * [func 函数 wait 延迟执行毫秒数 type 1 表时间戳版，2 表定时器版]
 */
const throttle = function (func, wait, type) {
  let previous: number = 0;
  let timeout: number | null = null;

  return function () {
    let context = this;
    let args = arguments;
    if (type === 1) {
      let now = Date.now();
      if (now - previous > wait) {
        func.apply(context, args);
        previous = now;
      }
    } else if (type === 2) {
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null;
          func.apply(context, args);
        }, wait);
      }
    }
  };
};
```

## 2. 函数防抖 (下方有另外的防抖处理函数)

```ts
/** 函数防抖
 * [func 函数,wait 延迟执行毫秒数,immediate true 表立即执行,false 表非立即执行,立即执行是触发事件后函数会立即执行，然后n秒内不触发事件才能继续执行函数的效果]
 */
const debounce = function (func, wait, immediate) {
  let timeout: number | null = null;
  return function () {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      var callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
};
```

## 3. H5 软键盘缩回、弹起回调

```ts
/** H5软键盘缩回、弹起回调
 * 当软件键盘弹起会改变当前 window.innerHeight
 * 监听这个值变化 [downCb 当软键盘弹起后，缩回的回调,upCb 当软键盘弹起的回调]
 */
const h5Resize = (downCb: () => void, upCb: () => void) => {
  let clientHeight = window.innerHeight;
  downCb = typeof downCb === "function" ? downCb : () => {};
  upCb = typeof upCb === "function" ? upCb : () => {};

  const debounce = (func: () => void, wait: number) => {
    let timeout: number | null = null;
    return () => {
      if (timeout) clearTimeout(timeout);
      timeout = window.setTimeout(func, wait);
    };
  };

  window.addEventListener(
    "resize",
    debounce(() => {
      let height = window.innerHeight;
      if (height === clientHeight) {
        downCb();
      } else if (height < clientHeight) {
        upCb();
      }
    }, 100)
  );
};
```

## 4. 获取 url 参数

```ts
/** 获取url参数 */
const getUrlParam = function (name: string): string | undefined {
  const url = new URL(window.location.href);
  const params = new URLSearchParams(url.search);
  const paramValue = params.get(name);
  return paramValue ? decodeURIComponent(paramValue) : undefined;
};

/** url参数转对象 */
const parseQueryString = function (url?: string): Record<string, string> {
  const query: Record<string, string> = {};
  const urlString = url || window.location.href;
  const urlObj = new URL(urlString);
  const params = new URLSearchParams(urlObj.search);

  params.forEach((value, key) => {
    query[decodeURIComponent(key)] = decodeURIComponent(value);
  });

  return query;
};
```

## 5. 对象序列化

```ts
/** 对象序列化
 * [对象转url参数]
 */
const stringfyQueryString = (obj: Record<string, any>): string => {
  if (!obj) return "";
  const pairs: string[] = [];

  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        pairs.push(
          `${encodeURIComponent(key)}[${index}]=${encodeURIComponent(item)}`
        );
      });
    } else {
      pairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
    }
  });

  return pairs.join("&");
};
```

## 6. 浏览器是否支持 webP 格式图片

```ts
/** 浏览器是否支持webP格式图片*/
const isSupportWebP = (): boolean => {
  try {
    return (
      !![].map &&
      document
        .createElement("canvas")
        .toDataURL("image/webp")
        .indexOf("data:image/webp") === 0
    );
  } catch (e) {
    return false;
  }
};
```

## 7. base64 图片下载功能

```ts
/** base64图片下载功能 */
const base64ToBlob = (code: string): Blob => {
  const parts = code.split(";base64,");
  const contentType = parts[0].split(":")[1];
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);

  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }

  return new Blob([uInt8Array], { type: contentType });
};

const downloadFile = (base64: string, fileName: string): void => {
  const blob = base64ToBlob(base64);
  const aLink = document.createElement("a");
  const evt = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
    view: window,
  });

  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  aLink.dispatchEvent(evt);
};
```

## 8. 图片地址转 base64

```ts
/** 图片地址转base64*/
const getBase64 = (
  img: string,
  width?: number,
  height?: number
): Promise<string> => {
  const getBase64Image = (
    img: HTMLImageElement,
    width?: number,
    height?: number
  ): string => {
    const canvas = document.createElement("canvas");
    canvas.width = width || img.width;
    canvas.height = height || img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL();
  };

  return new Promise((resolve, reject) => {
    const image = new Image();
    image.crossOrigin = "Anonymous";
    image.src = img;

    image.onload = () => {
      resolve(getBase64Image(image, width, height));
    };

    image.onerror = (err) => {
      reject(err);
    };
  });
};
```

## 9. 光标所在位置插入字符

```ts
/** 光标所在位置插入字符 */
const insertAtCursor = (
  dom: HTMLInputElement | HTMLTextAreaElement,
  val: string
): void => {
  dom.focus();

  if (
    typeof dom.selectionStart === "number" &&
    typeof dom.selectionEnd === "number"
  ) {
    const startPos = dom.selectionStart;
    const endPos = dom.selectionEnd;
    const restoreTop = dom.scrollTop;

    dom.value =
      dom.value.substring(0, startPos) +
      val +
      dom.value.substring(endPos, dom.value.length);

    if (restoreTop > 0) {
      dom.scrollTop = restoreTop;
    }

    dom.selectionStart = dom.selectionEnd = startPos + val.length;
  } else {
    dom.value += val;
  }
};
```

## 10. 音频加载完成操作

```ts
/** 音频加载完成操作 */
const loadAudio = (src, callback) => {
  const audio = new Audio(src);
  audio.onloadedmetadata = callback;
};
```

## 11. 判断图片加载完成

```ts
/** 判断图片加载完成 */
const imgLoadAll = (arr, callback) => {
  const arrImg = [];
  const promises = arr.map((src) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        arrImg.push(img);
        resolve();
      };
      img.onerror = reject;
    });
  });

  Promise.all(promises)
    .then(() => {
      callback && callback();
    })
    .catch((error) => {
      console.error("图片加载失败:", error);
    });
};
```

## 12. 原生 dom 操作

```ts
/** 原生dom操作 */
const dom = {
  $: (selector) => {
    const type = selector.charAt(0);
    if (type === "#") {
      return document.querySelector(selector);
    } else if (type === ".") {
      return document.querySelectorAll(selector);
    } else {
      return document.querySelectorAll(selector);
    }
  },
  hasClass: (ele, name) => {
    /* 检测类名 */
    return new RegExp(`(\\s|^)${name}(\\s|$)`).test(ele.className);
  },
  addClass: (ele, name) => {
    /* 添加类名 */
    if (!dom.hasClass(ele, name)) ele.className += ` ${name}`;
  },
  removeClass: (ele, name) => {
    /* 删除类名 */
    if (dom.hasClass(ele, name)) {
      const reg = new RegExp(`(\\s|^)${name}(\\s|$)`);
      ele.className = ele.className.replace(reg, " ");
    }
  },
  replaceClass: (ele, newName, oldName) => {
    /* 替换类名 */
    dom.removeClass(ele, oldName);
    dom.addClass(ele, newName);
  },
  siblings: (ele) => {
    /* 获取兄弟节点 */
    const children = Array.from(ele.parentNode.children);
    return children.filter((child) => child !== ele);
  },
  getByStyle: (obj, name) => {
    /* 获取行间样式属性 */
    return window.getComputedStyle
      ? getComputedStyle(obj, false)[name]
      : obj.currentStyle[name];
  },
  domToString: (htmlDOM) => {
    /* DOM转字符串 */
    const div = document.createElement("div");
    div.appendChild(htmlDOM);
    return div.innerHTML;
  },
  stringToDom: (htmlString) => {
    /* 字符串转DOM */
    const div = document.createElement("div");
    div.innerHTML = htmlString;
    return div.children[0];
  },
};
```

## 13. 阿拉伯数字转中文大写数字

```ts
/** 阿拉伯数字转中文大写数字 */
const numberToChinese = (num) => {
  // 将阿拉伯数字翻译成中文的大写数字
  const AA = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];
  const BB = ["", "十", "百", "仟", "萬", "億", "点", ""];
  const a = ("" + num).replace(/(^0*)/g, "").split(".");
  let k = 0;
  let re = "";

  for (let i = a[0].length - 1; i >= 0; i--) {
    switch (k) {
      case 0:
        re = BB[7] + re;
        break;
      case 4:
        if (!new RegExp(`0{4}\\d{${a[0].length - i - 1}}$`).test(a[0])) {
          re = BB[4] + re;
        }
        break;
      case 8:
        re = BB[5] + re;
        BB[7] = BB[5];
        k = 0;
        break;
    }
    if (
      k % 4 === 2 &&
      a[0].charAt(i + 2) !== "0" &&
      a[0].charAt(i + 1) === "0"
    ) {
      re = AA[0] + re;
    }
    if (a[0].charAt(i) !== "0") {
      re = AA[a[0].charAt(i)] + BB[k % 4] + re;
    }
    k++;
  }

  if (a.length > 1) {
    // 加上小数部分(如果有小数部分)
    re += BB[6];
    for (let i = 0; i < a[1].length; i++) {
      re += AA[a[1].charAt(i)];
    }
  }

  if (re === "一十") {
    re = "十";
  }
  if (re.match(/^一/) && re.length === 3) {
    re = re.replace("一", "");
  }

  return re;
};
```

## 14. 生成随机数范围

```ts
/** 生成随机数范围 */
const random = (min, max) => {
  // 检查参数是否为数字
  if (typeof min !== "number" || typeof max !== "number") {
    return null;
  }

  // 生成随机数范围
  return Math.floor(min + Math.random() * (max + 1 - min));
};
```

## 15. 过滤 html 代码

```ts
const filterTag = (str) => {
  // 过滤html代码(把<>转换)
  return str
    .replace(/&/g, "&")
    .replace(/</g, "<")
    .replace(/>/g, ">")
    .replace(/ /g, " ");
};
```

## 16. 字符串大小写转换

```ts
/** 字符串大小写转换 */
const changeCase = (str, type = 4) => {
  switch (type) {
    case 1:
      return str.replace(
        /\b\w+\b/g,
        (word) =>
          `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`
      );
    case 2:
      return str.replace(
        /\b\w+\b/g,
        (word) =>
          `${word.charAt(0).toLowerCase()}${word.slice(1).toUpperCase()}`
      );
    case 3:
      return str
        .split("")
        .map((char) =>
          /[a-z]/.test(char) ? char.toUpperCase() : char.toLowerCase()
        )
        .join("");
    case 4:
      return str.toUpperCase();
    case 5:
      return str.toLowerCase();
    default:
      return str;
  }
};
```

## 17. 去除字符串空格

```ts
/** 去除字符串空格 */
const trim = (str, type = 1) => {
  switch (type) {
    case 1:
      return str.replace(/\s+/g, "");
    case 2:
      return str.replace(/^\s+|\s+$/g, "");
    case 3:
      return str.replace(/^\s+/g, "");
    case 4:
      return str.replace(/\s+$/g, "");
    default:
      return str;
  }
};
```

## 18. 是否为 PC 端

```ts
/** 是否为PC端 */
const isPC = () => {
  // 是否为PC端
  const userAgentInfo = navigator.userAgent;
  const Agents = [
    "Android",
    "iPhone",
    "SymbianOS",
    "Windows Phone",
    "iPad",
    "iPod",
  ];
  return !Agents.some((agent) => userAgentInfo.includes(agent));
};
```

## 19. 常用正则验证

```ts
/** 常用正则验证 */
const checkStr = (str, type) => {
  const patterns = {
    phone: /^1[3-9]\d{9}$/, // 手机号码
    tel: /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/, // 座机
    card: /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/, // 身份证
    pwd: /^[a-zA-Z]\w{5,17}$/, // 密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线
    postal: /[1-9]\d{5}(?!\d)/, // 邮政编码
    QQ: /^[1-9][0-9]{4,9}$/, // QQ号
    email: /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/, // 邮箱
    money: /^\d*(?:\.\d{0,2})?$/, // 金额(小数点2位)
    URL: /(http|ftp|https):\/\/[\w-_]+(\.[\w-_]+)+([\w-.,@?^=%&:/~+#]*[\w-@?^=%&/~+#])?/, // 网址
    IP: /((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))/, // IP
    date: /^(\d{4})-(\d{2})-(\d{2})( (\d{2})(?::\d{2}|:(\d{2}):(\d{2}))?)?$/, // 日期时间
    number: /^[0-9]$/, // 数字
    english: /^[a-zA-Z]+$/, // 英文
    chinese: /^[\u4E00-\u9FA5]+$/, // 中文
    lower: /^[a-z]+$/, // 小写
    upper: /^[A-Z]+$/, // 大写
    HTML: /<("[^"]*"|'[^']*'|[^'">])*>/, // HTML标记
  };

  return patterns[type] ? patterns[type].test(str) : true;
};
```

## 20. 时间与时间戳转换

```ts
/** 时间与时间戳转换 */
const stamp = {
  // 时间，时间戳转换
  getTime: (time = new Date()) => {
    // 时间转10位时间戳
    const date = new Date(time);
    return Math.round(date.getTime() / 1000);
  },
};
```

## 21. 判断两个数组是否相等

```ts
/** 判断两个数组是否相等 */
const arrayEqual = (arr1, arr2) => {
  // 判断两个数组是否相等
  if (arr1 === arr2) return true;
  if (arr1.length !== arr2.length) return false;
  return arr1.every((value, index) => value === arr2[index]);
};
```

## 22. 判断是否是一个数组

```ts
/** 判断是否是一个数组 */
const isArray = (arr) => Array.isArray(arr);
```

## 23. 文本复制功能

```ts
/** 文本复制功能 */
const copyTxt = (text, fn) => {
  // 复制功能
  if (typeof document.execCommand !== "function") {
    console.log("复制失败，请长按复制");
    return;
  }

  const dom = document.createElement("textarea");
  dom.value = text;
  dom.setAttribute("style", "display: block;width: 1px;height: 1px;");
  document.body.appendChild(dom);
  dom.select();

  const result = document.execCommand("copy");
  document.body.removeChild(dom);

  if (result) {
    console.log("复制成功");
    if (typeof fn === "function") fn();
    return;
  }

  if (typeof document.createRange !== "function") {
    console.log("复制失败，请长按复制");
    return;
  }

  const range = document.createRange();
  const div = document.createElement("div");
  div.innerHTML = text;
  div.setAttribute("style", "height: 1px;font-size: 1px;overflow: hidden;");
  document.body.appendChild(div);
  range.selectNode(div);

  const selection = window.getSelection();
  if (selection.rangeCount > 0) {
    selection.removeAllRanges();
  }
  selection.addRange(range);

  document.execCommand("copy");
  document.body.removeChild(div);

  if (typeof fn === "function") fn();
  console.log("复制成功");
};
```

## 24. 判断是否为微信

```ts
/** 判断是否为微信 */
const isWx = () => {
  // 判断是否为微信
  const ua = window.navigator.userAgent.toLowerCase();
  return ua.includes("micromessenger");
};
```

## 25. 用户设备判断 Mac|iPod|iPhone|iPad

```ts
/** 用户设备判断 Mac|iPod|iPhone|iPad */
const fetchRequest = (url, setting = {}) => {
  const opts = {
    method: (setting.method || "GET").toUpperCase(),
    headers: setting.headers || {},
    credentials:
      setting.credentials !== undefined ? setting.credentials : "include",
    body: setting.body || {},
    mode: setting.mode || "no-cors",
    redirect: setting.redirect || "follow",
    cache: setting.cache || "default",
  };

  const dataType = setting.dataType || "json";
  const data = setting.data || "";

  const paramsFormat = (obj) => new URLSearchParams(obj).toString();

  if (opts.method === "GET") {
    url = url + (data ? `?${paramsFormat(data)}` : "");
  } else {
    opts.body = JSON.stringify(data);
  }

  return new Promise((resolve, reject) => {
    fetch(url, opts)
      .then(async (res) => {
        let result;
        if (dataType === "text") {
          result = await res.text();
        } else if (dataType === "blob") {
          result = await res.blob();
        } else {
          result = await res.json();
        }
        resolve(result);
      })
      .catch((e) => {
        reject(e);
      });
  });
};
```

## 26. 原生 ajax 操作

```ts
/** 原生ajax操作 */
const ajax = (conf) => {
  const {
    url,
    data,
    async = true,
    type = "GET",
    dataType = "json",
    contentType = "application/x-www-form-urlencoded",
    success,
    error,
    isForm = false,
    header = {},
  } = conf;

  const paramsFormat = (obj) => new URLSearchParams(obj).toString();

  const fetchOptions = {
    method: type.toUpperCase(),
    headers: {
      "Content-Type": contentType,
      ...header,
    },
    credentials: "same-origin",
  };

  if (fetchOptions.method === "GET") {
    url += data ? `?${paramsFormat(data)}` : "";
  } else {
    fetchOptions.body = isForm ? data : paramsFormat(data);
  }

  fetch(url, fetchOptions)
    .then(async (response) => {
      if (!response.ok) {
        throw new Error(`通讯失败! ${response.status}`);
      }
      let result;
      if (dataType === "json") {
        result = await response.json();
      } else if (dataType === "text") {
        result = await response.text();
      } else if (dataType === "blob") {
        result = await response.blob();
      }
      if (success) success(result);
    })
    .catch((err) => {
      if (error) error(err.message);
    });
};
```

## 27. 时间格式化

```ts
/** 时间格式化 */ const formatDate = (fmt, date) => {
  // 时间格式化 【'yyyy-MM-dd hh:mm:ss',时间】
  if (typeof date !== "object") {
    date = !date ? new Date() : new Date(date);
  }

  const o = {
    "M+": date.getMonth() + 1, // 月份
    "d+": date.getDate(), // 日
    "h+": date.getHours(), // 小时
    "m+": date.getMinutes(), // 分
    "s+": date.getSeconds(), // 秒
    "q+": Math.floor((date.getMonth() + 3) / 3), // 季度
    S: date.getMilliseconds(), // 毫秒
  };

  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(
      RegExp.$1,
      (date.getFullYear() + "").substr(4 - RegExp.$1.length)
    );
  }

  for (const k in o) {
    if (new RegExp(`(${k})`).test(fmt)) {
      fmt = fmt.replace(
        RegExp.$1,
        RegExp.$1.length === 1 ? o[k] : `00${o[k]}`.substr(`${o[k]}`.length)
      );
    }
  }

  return fmt;
};
```

## 28. Js 获取元素样式【支持内联】

```ts
/** Js获取元素样式【支持内联】 */
const getRealStyle = (obj, styleName) => {
  if (obj.currentStyle) {
    return obj.currentStyle[styleName];
  } else if (window.getComputedStyle) {
    return window.getComputedStyle(obj, null)[styleName];
  }
  return null;
};
```

## 29. cookie 操作【set，get，del】

```ts
/** cookie操作【set，get，del】 */
const cookie = {
  set: function (name, value, day) {
    let oDate = new Date();
    oDate.setDatconst loadRes = (name, type) => {
  return new Promise((resolve, reject) => {
    let ref;
    if (type === "js") {
      // 外部js
      ref = document.createElement("script");
      ref.setAttribute("type", "text/javascript");
      ref.setAttribute("src", name);
    } else if (type === "css") {
      // 外部css
      ref = document.createElement("link");
      ref.setAttribute("rel", "stylesheet");
      ref.setAttribute("type", "text/css");
      ref.setAttribute("href", name);
    } else if (type === "style") {
      // style
      ref = document.createElement("style");
      ref.innerHTML = name;
    }

    if (ref) {
      document.getElementsByTagName("head")[0].appendChild(ref);
      ref.onload = () => resolve();
      ref.onerror = () => reject(new Error(`Failed to load resource: ${name}`));
    } else {
      reject(new Error(`Invalid resource type: ${type}`));
    }
  });
};

// 使用示例
loadRes('path/to/resource.js', 'js')
  .then(() => {
    console.log('Resource loaded successfully');
  })
  .catch((error) => {
    console.error(error);
  });   const data = localStorage.getItem(name);
    if (!data) {
      return null;
    }
    const obj = JSON.parse(data);
    if (new Date().getTime() > obj.time) {
      // 过期
      localStorage.removeItem(name);
      return null;
    } else {
      return obj.data;
    }
  },
  clear: (name) => {
    // 清空
    if (name) {
      // 删除键为name的缓存
      localStorage.removeItem(name);
    } else {
      // 清空全部
      localStorage.clear();
    }
  },
};
```

## 31. 加载 js || css || style

```ts
/** 加载 js || css || style */
const loadRes = function (name, type, fn) {
  // 加载js || css || style
  let ref;
  if (type === "js") {
    // 外部js
    ref = document.createElement("script");
    ref.setAttribute("type", "text/javascript");
    ref.setAttribute("src", name);
  } else if (type === "css") {
    // 外部css
    ref = document.createElement("link");
    ref.setAttribute("rel", "stylesheet");
    ref.setAttribute("type", "text/css");
    ref.setAttribute("href", name);
  } else if (type === "style") {
    // style
    ref = document.createElement("style");
    ref.innerhtml = name;
  }
  if (typeof ref !== "undefined") {
    document.getElementsByTagName("head")[0].appendChild(ref);
    ref.onload = function () {
      // 加载完成执行
      typeof fn === "function" && fn();
    };
  }
};
```

## 32. js 获取文件名后缀

1. 方式一：subtring()

```ts
/** 使用subtring() 截取字符串，对于文件名中会出现多个点的很有用，从最后一个点的地方截取。 */
const getSuffix = (name, includeDot = true) => {
  const lastIndex = name.lastIndexOf(".");
  if (lastIndex === -1) return ""; // 如果没有找到点，返回空字符串
  return includeDot ? name.substring(lastIndex) : name.substring(lastIndex + 1);
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

2. 方式二：正则

```ts
/** 使用正则，对只会出现一个点的适用： */
const getSuffix = (name, includeDot = true) => {
  const match = name.match(includeDot ? /.[^.]+$/ : /[^.]+$/);
  return match ? match[0] : "";
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

3. 方式三：转数组

```ts
const getSuffix = (name) => {
  const parts = name.split(".");
  return parts.length > 1 ? `.${parts.pop()}` : "";
};

// 使用示例
const fileName = "example.txt";
const suffix = getSuffix(fileName); // ".txt"

console.log(suffix); // 输出: .txt
```

4. 方式四：substr()

```ts
/** 同subtring()的字符串截取 */
const getSuffix = (name, includeDot = true) => {
  const lastIndex = name.lastIndexOf(".");
  if (lastIndex === -1) return ""; // 如果没有找到点，返回空字符串
  return includeDot ? name.substr(lastIndex) : name.substr(lastIndex + 1);
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

## 33. 随机获取布尔值

```ts
/** 随机获取布尔值
 * Math.random() 输出 0 - 1 之间的随机数，然后判断这个随机数是否大于等于 0.5。这就说明有 50% 的机会得到真值或假值。
 */
const randomBoolean = (probability = 0.5) => Math.random() < probability;
// 使用示例
console.log(randomBoolean()); // 默认 50% 概率返回 true
console.log(randomBoolean(0.7)); // 70% 概率返回 true
console.log(randomBoolean(0.3)); // 30% 概率返回 true
```

## 34. 判断给的日期是工作日还是双休日

```ts
/** 判断给的日期是工作日还是双休日 */
const isWeekday = (date) => {
  if (!(date instanceof Date) || isNaN(date)) {
    throw new Error("Invalid date");
  }
  return date.getDay() % 6 !== 0;
};

// 使用示例
console.log(isWeekday(new Date(2021, 0, 11))); // 结果: true (Monday)
console.log(isWeekday(new Date(2021, 0, 10))); // 结果: false (Sunday)
```

## 35. 反转字符串

```ts
/** 反转字符串 */
const reverse = (str) => {
  if (typeof str !== "string") {
    throw new Error("Input must be a string");
  }
  return str.split("").reverse().join("");
};

// 使用示例
console.log(reverse("hello world")); // 结果: 'dlrow olleh'
```

## 36. 判断数字是偶数还是奇数

```ts
/** 判断数字是偶数还是奇数 */
const isEven = (num) => {
  if (typeof num !== "number") {
    throw new Error("Input must be a number");
  }
  return num % 2 === 0;
};

// 使用示例
console.log(isEven(2)); // 结果: true
console.log(isEven(3)); // 结果: false
console.log(isEven("4")); // 抛出错误: Input must be a number
```

## 37. 从日期获取当地时间

```ts
/** 从日期获取当地时间 */
const timeFromDate = (date) => {
  if (!(date instanceof Date) || isNaN(date)) {
    throw new Error("Invalid date");
  }
  return date.toTimeString().slice(0, 8);
};

// 使用示例
console.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0)));
// 结果: "17:30:00"
console.log(timeFromDate(new Date()));
// 结果: will log the current time
```

## 38. 使用 Math.pow()方法，将数字四舍五入到固定的小数点

```ts
/** 使用Math.pow()方法，将数字四舍五入到固定的小数点 */
const toFixed = (n, fixed) => {
  if (typeof n !== "number" || typeof fixed !== "number" || fixed < 0) {
    throw new Error("Invalid input");
  }
  return n.toFixed(fixed);
};

// Examples
console.log(toFixed(25.198726354, 1)); // 结果: "25.2"
console.log(toFixed(25.198726354, 2)); // 结果: "25.20"
console.log(toFixed(25.198726354, 3)); // 结果: "25.199"
console.log(toFixed(25.198726354, 4)); // 结果: "25.1987"
console.log(toFixed(25.198726354, 5)); // 结果: "25.19873"
console.log(toFixed(25.198726354, 6)); // 结果: "25.198726"
```

## 39. 使用 document.activeElement 属性，检查元素当前是否处于焦点

```ts
/** 使用 document.activeElement 属性，检查元素当前是否处于焦点 */
const elementIsInFocus = (el) => {
  if (!(el instanceof Element)) {
    throw new Error("Input must be a DOM element");
  }
  return el === document.activeElement;
};

// 使用示例
const anyElement = document.querySelector("input");
console.log(elementIsInFocus(anyElement)); // 结果: 如果元素在焦点中返回 true，否则返回 false
```

## 40. 获取所有参数平均值

```ts
/**  获取所有参数平均值 */
const average = (...args) => {
  if (args.length === 0) {
    throw new Error("At least one number is required");
  }
  if (!args.every((arg) => typeof arg === "number")) {
    throw new Error("All arguments must be numbers");
  }
  return args.reduce((a, b) => a + b, 0) / args.length;
};

// 使用示例
console.log(average(1, 2, 3, 4)); // 结果: 2.5
console.log(average(5, 10)); // 结果: 7.5
console.log(average()); // 抛出错误: At least one number is required
console.log(average(1, "2", 3)); // 抛出错误: All arguments must be numbers
```

## 41. 如何获取两个日期之间的天数间隔

```ts
const getDaysDiffBetweenDates = (dateInitial, dateFinal) => {
  if (
    !(dateInitial instanceof Date) ||
    isNaN(dateInitial) ||
    !(dateFinal instanceof Date) ||
    isNaN(dateFinal)
  ) {
    throw new Error("Both arguments must be valid Date objects");
  }
  const msPerDay = 1000 * 3600 * 24;
  return (dateFinal - dateInitial) / msPerDay;
};

// Example
console.log(
  getDaysDiffBetweenDates(new Date("2017-12-13"), new Date("2017-12-22"))
); // 结果: 9
```

## 42. 如何获得给定毫秒数的可读格式

```ts
/** 如何获得给定毫秒数的可读格式 */
const formatDuration = (ms, showMilliseconds = true) => {
  if (typeof ms !== "number" || isNaN(ms)) {
    throw new Error("Input must be a valid number");
  }
  if (ms < 0) ms = -ms;
  const time = {
    day: Math.floor(ms / 86400000),
    hour: Math.floor(ms / 3600000) % 24,
    minute: Math.floor(ms / 60000) % 60,
    second: Math.floor(ms / 1000) % 60,
    millisecond: Math.floor(ms) % 1000,
  };
  return Object.entries(time)
    .filter(
      ([key, val]) => val !== 0 && (showMilliseconds || key !== "millisecond")
    )
    .map(([key, val]) => `${val} ${key}${val !== 1 ? "s" : ""}`)
    .join(", ");
};

// Examples
console.log(formatDuration(1001)); // 结果: "1 second, 1 millisecond"
console.log(formatDuration(34325055574)); // 结果: "397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds"
console.log(formatDuration(34325055574, false)); // 结果: "397 days, 6 hours, 44 minutes, 15 seconds"
```

## 43. 如何确定页面的浏览器选项卡是否处于前台活跃状态

```ts
/** 如何确定页面的浏览器选项卡是否处于前台活跃状态 */
const isBrowserTabFocused = () => {
  if (typeof document === "undefined") {
    throw new Error("This function can only be run in a browser environment");
  }
  return !document.hidden;
};

// Example
console.log(isBrowserTabFocused()); // 结果: true 或 false，取决于浏览器标签是否在焦点中
```

## 44. 按比例缩放二维向量（宽度和高度），使其最大尺寸不超过指定的限制

```ts
/** 按比例缩放二维向量（宽度和高度），使其最大尺寸不超过指定的限制 */
type Vector2 = import("@use-gesture/react").Vector2;

const MAX_LIMIT = 800;
export const scaleSize = (
  size: Vector2,
  limit: number = MAX_LIMIT
): Vector2 => {
  const max = Math.max(...size);
  if (max <= limit) {
    return size;
  }
  if (size[0] > size[1]) {
    const scale = limit / size[0];
    return [limit, size[1] * scale];
  }
  const scale = limit / size[1];
  return [size[0] * scale, limit];
};
```

## 45. 保存图片图像

```ts
/** 保存图片图像
 * 该方法首先检查背景 URL 是否以 'image://' 开头，如果是则直接返回。否则，它会获取图像数据，将其编码为 Base64 字符串并保存。如果保存失败，则抛出错误；如果成功，则返回并设置背景图像。
 * tw.widget.saveImage() 方法用于保存图像数据，它接受一个对象作为参数，该对象包含图像数据的 Base64 字符串。如果保存成功，则返回一个包含图像 URL 的对象；否则返回一个空对象。
 */
import { Base64 } from "js-base64";

async function saveBackground() {
  if (this.backgroundUrl?.startsWith("image://")) {
    return this.backgroundUrl;
  }
  const buffer = await fetch(this.backgroundUrl!).then((res) =>
    res.arrayBuffer()
  );
  const result = await tw.widget.saveImage({
    data: Base64.fromUint8Array(new Uint8Array(buffer)),
  });
  if (!result.value) {
    throw new Error("Save Background Image Failed");
  }
  return (this.background = result.value);
}
```

## 46. 返回一个 Promise，并在指定的毫秒数 (ms) 后解决(resolve)

```ts
/** 返回一个 Promise，并在指定的毫秒数 (ms) 后解决（resolve) */
export const sleep = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

async function example() {
  console.log("等待 2 秒...");
  await sleep(2000);
  console.log("2 秒后");
}

example();
```

## 47. 获取指定路径的字符串内容，并将其缓存以提高后续访问的效率

```ts
/** 获取指定路径的字符串内容，并将其缓存以提高后续访问的效率
 * 处理带有命名空间的本地存储操作。它提供了设置、获取、删除单个项以及删除所有项的方法。
 */
import { BUNDLE_ID } from "@/env";

declare class LocalStorage<
  T extends Record<string, unknown> = Record<string, unknown>
> {
  constructor(namespace: string);

  setItem<K extends keyof T, V = T[K]>(key: K, value: V): Promise<0>;

  getItem<K extends keyof T, V = T[K]>(key: K): Promise<V | null>;

  removeItem<K extends keyof T>(key: K): Promise<0>;

  removeAll(): Promise<0>;
}

const storage = new LocalStorage(BUNDLE_ID);

export default storage;

const PATH_STRING_CACHE = new Map<string, string>();

export const getPathString = async (path: string): Promise<string | null> => {
  if (PATH_STRING_CACHE.has(path)) {
    return PATH_STRING_CACHE.get(path) as string;
  }
  const cache = await storage.getItem<string, string | null>(`PATH_${path}`);
  if (cache) {
    PATH_STRING_CACHE.set(path, cache!);
    return cache!;
  }
  const res = await fetch(path);
  const pathString = await res.text();
  PATH_STRING_CACHE.set(path, pathString);
  storage.setItem(`PATH_${path}`, pathString);
  return pathString;
};
```

## 48. 计算一个矩形在另一个矩形内完全覆盖时的尺寸和位置

```ts
/** 计算一个矩形在另一个矩形内完全覆盖时的尺寸和位置
 * 确保一个矩形在另一个矩形内完全覆盖，并且居中显示。
 */
type Vector2 = import("@use-gesture/react").Vector2;

export const getCoveredRect = (size: Vector2, boundedSize: Vector2) => {
  const [width, height] = size;
  const [boundedWidth, boundedHeight] = boundedSize;
  const ratio = Math.max(boundedWidth / width, boundedHeight / height);
  const coveredWidth = width * ratio;
  const coveredHeight = height * ratio;
  return {
    width: coveredWidth,
    height: coveredHeight,
    x: (boundedWidth - coveredWidth) / 2,
    y: (boundedHeight - coveredHeight) / 2,
  };
};
```

## 49. 加载图像

```ts
/** 加载图像
 * 创建一个新的图像对象并设置其 src 属性来加载图像。它返回一个 Promise，当图像成功加载时，Promise 会被解析并返回图像对象；如果加载失败，Promise 会被拒绝。
 */

export const loadImage = (url: string) => {
  return new Promise<HTMLImageElement>((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
};
```

## 50. 将角度转换为弧度

```ts
/** 将角度转换为弧度 */
export const angle2radian = (angle: number) => (angle * Math.PI) / 180;
```

## 51. 将输入字符串的第一个字符转换为大写，其余字符转换为小写

```ts
/** 将输入字符串的第一个字符转换为大写，其余字符转换为小写 */
export const uppercase = (s: string) => {
  const [f, ...r] = s;
  return `${f.toUpperCase()}${r.join("").toLowerCase()}`;
};
```

## 52. 借用一定数量的 canvas 元素。如果请求的数量超过 12，则抛出错误。否则，它会确保 CACHED_CANVAS 数组中有足够的 canvas 元素，并返回前 count 个 canvas 元素

```ts
/** 借用一定数量的 canvas 元素。如果请求的数量超过 12，则抛出错误。否则，它会确保 CACHED_CANVAS 数组中有足够的 canvas 元素，并返回前 count 个 canvas 元素 */

const CACHED_CANVAS: HTMLCanvasElement[] = [];
export const borrowCanvas = (count: number) => {
  if (count > 12) {
    throw new Error("Maximum canvas count is 12");
  }
  while (CACHED_CANVAS.length < count) {
    CACHED_CANVAS.push(document.createElement("canvas"));
  }
  return CACHED_CANVAS.slice(0, count);
};
```

## 53. 判断一个角度 angle 是否在目标角度 target 的阈值 threshold 范围内

```ts
/** 判断一个角度 angle 是否在目标角度 target 的阈值 threshold 范围内 */
export const resetReactive = <T>(obj: any) => {
  Object.keys(obj).forEach((key) => {
    delete obj[key];
  });
};
const obj = { a: 1, b: 2, c: 3 };
resetReactive(obj);
console.log(obj); // 输出: {}
```

## 54. 清空传入对象的所有属性

```ts
/** 清空传入对象的所有属性 */
export const resetReactive = <T>(obj: any) => {
  Object.keys(obj).forEach((key) => {
    delete obj[key];
  });
};
const obj = { a: 1, b: 2, c: 3 };
resetReactive(obj);
console.log(obj); // 输出: {}
```

## 55. 显示一个警告对话框，提示用户有未保存的更改，并根据用户的选择返回一个 Promis

```ts
/** 显示一个警告对话框，提示用户有未保存的更改，并根据用户的选择返回一个 Promis */

export const alertUnsavedChanges = () => {
  return new Promise<void>((resolve, reject) => {
    // 弹出对话框，别的项目使用需要更换
    tw.showAlert(
      {
        title: "未保存更改",
        message: "你的更改还未保存，确定要返回吗？",
        style: 1,
        actions: [
          { title: "取消", id: 0, style: 1 },
          { title: "确定", id: 1, style: 0 },
        ],
      },
      (id: number) => {
        if (id === 1) {
          resolve();
          return;
        }
        reject();
      }
    );
  });
};
```

## 56. 用于获取图像的元数据（宽度和高度）

```ts
/** 用于获取图像的元数据（宽度和高度）
 * 通过加载图像来获取其宽度和高度，并返回一个包含这些信息的 Promise。
 */

interface ImageMetadata {
  width: number;
  height: number;
}
export const getImageMetadata = (url: string) => {
  return new Promise<ImageMetadata>((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve({ width: img.width, height: img.height });
    img.onerror = reject;
    img.src = url;
  });
};
```

## 57. 压缩图像，使其尺寸不超过指定的最大宽度和高度

```ts
/** 压缩图像，使其尺寸不超过指定的最大宽度和高度 */
type Vector2 = import("@use-gesture/react").Vector2;
const COMPRESS_CANVAS = document.createElement("canvas");
const COMPRESS_CONTEXT = COMPRESS_CANVAS.getContext("2d")!;
export const compressImage = (url: string, maximum: Vector2 = [2000, 2000]) => {
  return new Promise<string>((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const [width, height] = [img.width, img.height];
      const [maxWidth, maxHeight] = maximum;
      const ratio = Math.min(maxWidth / width, maxHeight / height);
      COMPRESS_CONTEXT.clearRect(
        0,
        0,
        COMPRESS_CANVAS.width,
        COMPRESS_CANVAS.height
      );
      COMPRESS_CANVAS.width = width * ratio;
      COMPRESS_CANVAS.height = height * ratio;
      COMPRESS_CONTEXT.drawImage(img, 0, 0, width * ratio, height * ratio);
      COMPRESS_CANVAS.toBlob(
        (blob) => {
          const reader = new FileReader();
          reader.onload = () => {
            resolve(reader.result as string);
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob!);
        },
        "image/png",
        1
      );
    };
    img.onerror = reject;
    img.src = url;
  });
};
```

## 58. 版本控制

```ts
/**
 * compare two version and return the greater one
 * @example
 * compare('1.0.0', '0.1.1') => 0
 * compare('1.0.0', '1.0.0') => -1
 * compare('1.0', '1.1.1') => 1
 */
export function compare(v1: string, v2: string): 0 | 1 | -1 {
  const vArr1 = v1.split(".").map((item) => +item.trim());
  const vArr2 = v2.split(".").map((item) => +item.trim());
  while (vArr1.length > vArr2.length) {
    vArr2.push(0);
  }
  while (vArr1.length < vArr2.length) {
    vArr1.push(0);
  }
  for (let i = 0; i < vArr1.length; i++) {
    if (vArr1[i] > vArr2[i]) {
      return 0;
    }
    if (vArr1[i] < vArr2[i]) {
      return 1;
    }
  }
  return -1;
}

/**
 * v1 is lesser than v2
 * v1 小于 v2
 */
export const lt = (v1: string, v2: string) => compare(v1, v2) === 1;
/**
 * v1 is greater than v2
 * v1 大于 v2
 */
export const gt = (v1: string, v2: string) => compare(v1, v2) === 0;
/**
 * v1 is equal to v2
 * v1 等于 v2
 */
export const e = (v1: string, v2: string) => compare(v1, v2) === -1;
/**
 * v1 is greater than or equal to v2
 * v1 大于等于 v2
 */
export const gte = (v1: string, v2: string) => compare(v1, v2) !== 1;
/**
 * v1 is lesser than or equal to v2
 * v1 小于等于 v2
 */
export const lte = (v1: string, v2: string) => compare(v1, v2) !== 0;
```

## 59. 复制文本到剪贴板

```ts
const copyToClipboard = (text) => navigator.clipboard.writeText(text);

copyToClipboard("Hello, World!")
  .then(() => {
    console.log("Text copied to clipboard");
  })
  .catch((err) => {
    console.error("Failed to copy text: ", err);
  });
```

## 60. 横向滚动点击后居中

```html
<div class="" ref="scrollRef">
  <div
    key="{index}"
    className="w-40 h-40 bg-$secondaryButton flex
      items-center justify-center rounded-10 relative"
    onClick="moveCenter(e)"
  ></div>
</div>
```

```ts
const moveBox = (el: HTMLDivElement) => {
  // scrollRef.current 是滚动容器的 ref
  if (!scrollRef.current) return;
  const { left: targetX, width: targetW } = el.getBoundingClientRect();
  const scrollX = scrollRef.current.scrollLeft;
  const scrollW = scrollRef.current.getBoundingClientRect().width;
  const offset = targetX - scrollW / 2;
  scrollRef.current?.scrollTo({
    left: scrollX + offset + targetW / 2,
    behavior: "smooth",
  });
};

const moveCenter = (e) => {
  moveBox(e.currentTarget as HTMLDivElement);
};
```

## 61. 获取某个日期是当年的第几天

```ts
const dayOfYear = (date) => {
  return Math.floor(
    (date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24
  );
};

const text = dayOfYear(new Date(2020, 10, 27)); // 332
const text1 = dayOfYear(new Date());
console.log(text, text1);
```

## 62. 将图片转换为 Base64 编码的字符串

```ts
export function convertImageToBase64(
  url: string,
  clean = true
): Promise<string> {
  return new Promise((resolve, reject) => {
    url = url.replace(
      "top-widgets-oss-cdn.topwidgets.com",
      "top-widgets.oss-cn-shenzhen.aliyuncs.com"
    );
    url = url.replace(
      "storm-oss-cdn.topwidgets.com",
      "resource.topwidgets.com"
    );
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = function () {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx!.drawImage(img, 0, 0);
      const base64 = canvas.toDataURL("image/png");
      resolve(clean ? cleanBase64(base64) : base64);
    };
    img.onerror = reject;
    img.src = url;
  });
}
export const cleanBase64 = (str: string) => {
  return str.replace(/^data:image\/(png|jpg|jpeg);base64,/, "");
};
```

## 63. 将 rgb 颜色灰度化

```ts
const gray = (r, g, b) => 0.2126 * r + 0.7152 * g + 0.0722 * b;

console.log(gray(50, 100, 150)); // 92.9777777777777...
```

## 64. 解析 url 中的参数

```ts
const parseQuery = (url) => {
  q = {};
  url.replace(/([^?&=]+)=([^&]+)/g, (_, k, v) => (q[k] = v));
  return q;
};

const text1 = parseQuery("https://www.baidu.com/s?wd=js&name=hello"); // { wd: 'js', name: 'hello' }
const text2 = parseQuery("a=1&b=2"); // { a: '1', b: '2' }
console.log(text1);
console.log(text2);
```

## 65. 判断是否是数字

```ts
export const isNumberString = (v: string = "") => /^\d+$/.test(v);
```

## 66. 去掉字符串中的元素标记

```ts
const removeTag = (fragment) => {
  return (
    new DOMParser().parseFromString(fragment, "text/html").body.textContent ||
    ""
  );
};

const text = removeTag(`<div>Hello World</div>`);
console.log(text); // Hello World
```

## 67. 筛选对象属性

```ts
const pick = (obj, ...props) => {
  return Object.fromEntries(
    Object.entries(obj).filter(([k]) => props.includes(k))
  );
};

const text = pick({ a: 1, b: 2, c: 3 }, "a", "c"); // { a: 1, c: 3 }
console.log(text);
```

## 68. 生成一个随机字符串

```ts
const randomString = () => Math.random().toString(36).slice(2);

const text = randomString();
const text1 = randomString();
console.log(text, text1);
```

## 69. 随机 HEX 颜色

```ts
const randomColor = () => {
  return (
    "#" +
    Math.floor(Math.random() * 0xffffff)
      .toString(16)
      .padEnd(6, "0")
  );
};

const text1 = randomColor();
const text2 = randomColor();
const text3 = randomColor();
console.log(text1, text2, text3);
```

## 70. 压缩图片宽度

```ts
export function compressImageByWidth(
  url: string,
  maxWidth: number,
  quality: number
): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function () {
      const canvas = document.createElement("canvas");
      let width = img.width;
      let height = img.height;
      if (width > maxWidth) {
        height *= maxWidth / width;
        width = maxWidth;
      }
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx!.drawImage(img, 0, 0, width, height);
      const base64 = canvas.toDataURL("image/png");
      resolve(base64);
    };
    img.onerror = reject;
    img.src = url;
  });
}
```

## 71. ipad 方法

```ts
export const onOrientationChange = (callback: () => void) => {
  const mql = window.matchMedia("(orientation: portrait)");
  mql.addEventListener("change", () => {
    callback();
  });
};
export function getOrientation() {
  const isLandscape = window.matchMedia("(orientation: landscape)").matches;
  return isLandscape ? "landscape" : "portrait";
}
export const getRealWidthAndHeight = () => {
  const orientation = getOrientation();
  if (orientation === "landscape") {
    const width = Math.max(window.screen.width, window.screen.height);
    const height = Math.min(window.screen.width, window.screen.height);
    return {
      width,
      height,
    };
  } else {
    const width = Math.min(window.screen.width, window.screen.height);
    const height = Math.max(window.screen.width, window.screen.height);
    return {
      width,
      height,
    };
  }
};
```

## 72. Promise 解决接口超时

1. 方式一：

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  // 假设请求需要 1s
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return new Promise((resolve, reject) => {
    const promises = [requestFn(), sleep(delay)];
    for (const promise of promises) {
      // 超时则执行失败，不超时则执行成功
      promise.then(
        (res) => resolve(res),
        (err) => reject(err)
      );
    }
  });
}

// 超时
timeoutPromise(request, 500).catch((err) => console.log(err)); // 接口超时

// 不超时
timeoutPromise(request, 2000).then((res) => console.log(res)); // 接口成功
```

2. 方式二: promise.race

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  // 假设请求需要 1s
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
// promise.race可以代替手写的超时判断
function timeoutPromise(requestFn, delay) {
  // 如果先返回的是延迟Promise则说明超时了
  // race会直接返回最先执行完的Promise
  return Promise.race([requestFn(), sleep(delay)]);
}

// 超时
timeoutPromise(request, 500).catch((err) => console.log(err)); // 接口超时

// 不超时
timeoutPromise(request, 2000).then((res) => console.log(res)); // 接口成功
```

## 73. Promise 解决转盘问题

1. 方式一: 转盘转动完成前数据就回来了

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 模拟转盘旋转到停止的延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function turntableSleep(delay) {
  return new Promise((resolve) => {
    setTimeout(() => resolve("转盘停止转动"), delay);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return Promise.race([requestFn(), sleep(delay)]);
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} turntableDelay 转盘转多久
 * @param {number} delay 请求超时时长
 * @returns {Promise<any>}
 */

function turntablePromise(requestFn, turntableDelay, delay) {
  return Promise.all([
    timeoutPromise(requestFn, delay),
    turntableSleep(turntableDelay),
  ]);
}

// 不超时，且先于转盘停止前请求回数据
turntablePromise(request, 2500, 1500).then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

2. 方式二: 转盘转动完成数据未回来

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return Promise.race([requestFn(), sleep(delay)]);
}

// 不超时，且先于转盘停止前请求回数据
timeoutPromise(request, 2500, 1500).then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

## 74. Promise 控制并发接口

```ts
/** Promise控制并发(如果需要一次性发送过多请求，可以使用Promise控制并发， 先发送一部分请求，等这一部分请求完成后再发送下一部分请求)
 * 1. 限制并发数
 * 2. 任务完成后，返回结果
 * 3. 任务失败后，返回失败原因
 * 4. 任务完成后，继续添加任务
 * 5. 任务失败后，继续添加任务
 */
class Scheduler {
  constructor(limit) {
    this.dataList = [];
    // 限制并发数
    this.limit = limit;
    this.count = 0;
  }

  // 添加任务的方法
  add(time, order) {
    const promiseCreator = () => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(order);
          resolve();
        }, time);
      });
    };
    this.dataList.push(promiseCreator);
  }

  taskStart() {
    for (let i = 0; i < this.limit; i++) {
      this.request();
    }
  }

  request() {
    if (!this.dataList.length || this.count >= this.limit) return;
    this.count++;
    this.dataList
      .shift()()
      .then(() => {
        this.count--;
        this.request();
      });
  }
}

// 测试
const scheduler = new Scheduler(2);
const addTask = (time, order) => {
  scheduler.add(time, order);
};
addTask(1000, "1");
addTask(500, "2");
addTask(300, "3");
addTask(400, "4");
scheduler.taskStart();
```

## 75. Promise 取消重复请求

```ts
/** 取消重复请求
 * 1. 保证只有一个请求在执行
 * 2. 如果有新请求，取消之前的请求
 * 3. 如果请求已经完成，不会取消
 * 4. 如果请求已经取消，不会执行回调
 * 5. 如果请求失败，不会执行回调
 * 6. 如果请求成功，执行回调
 * 7. 如果请求被取消，执行回调
 * 8. 如果请求被取消，不会执行回调
 */

class CancelablePromise {
  constructor() {
    this.pendingPromise = null;
    this.reject = null;
  }

  request(requestFn) {
    if (this.pendingPromise) {
      this.cancel("取消重复请求");
    }

    const promise = new Promise((_, reject) => (this.reject = reject));
    this.pendingPromise = Promise.race([requestFn(), promise]);
    return this.pendingPromise;
  }

  cancel(reason) {
    this.reject(reason);
    this.pendingPromise = null;
  }
}

function request(delay) {
  return () =>
    new Promise((resolve) => {
      setTimeout(() => {
        resolve("最后赢家是我");
      }, delay);
    });
}

const cancelPromise = new CancelablePromise();

// 模拟频繁请求5次
for (let i = 0; i < 5; i++) {
  cancelPromise
    .request(request(2000))
    .then((res) => console.log(res)) // 最后一个 最后赢家是我
    .catch((err) => console.error(err)); // 前四个 取消重复请求
}
```

## 76. Promise 全局请求 loading

```ts
/** promise全局请求loading
 * 全局只要有一个接口还在请求中就展示loading
 * 全局所有接口请求完后隐藏loading
 */

class PromiseManager {
  constructor() {
    this.pendingPromise = new Set();
    this.loading = false;
  }

  generateKey() {
    return `${new Date().getTime()}-${parseInt(Math.random() * 1000)}`;
  }

  push(...requestFns) {
    for (const requestFn of requestFns) {
      const key = this.generateKey();
      this.pendingPromise.add(key);
      requestFn().finally(() => {
        this.pendingPromise.delete(key);
        this.loading = this.pendingPromise.size !== 0;
      });
    }
  }
}

// 模拟请求
function request(delay) {
  return () => {
    return new Promise((resolve) => {
      setTimeout(() => resolve("成功喽"), delay);
    });
  };
}

const manager = new PromiseManager();

manager.push(
  request(1000),
  request(2000),
  request(800),
  request(2000),
  request(1500)
);

const timer = setInterval(() => {
  // 轮询查看loading状态
  console.log(manager.loading);
}, 300);
```

## 77. 操作 dom Class

```ts
// 检查元素是否包含指定的CSS类
function hasClass(elem: Element, cls = "") {
  if (cls.replace(/\s/g, "").length === 0) return false; //当cls没有参数时，返回false
  return new RegExp(" " + cls + " ").test(" " + elem.className + " ");
}

// 添加指定的CSS类
function addClass(elem: Element, cls: string) {
  if (!hasClass(elem, cls)) {
    elem.className = elem.className === "" ? cls : elem.className + " " + cls;
  }
}

// 删除指定的CSS类
function removeClass(elem: Element, cls: string) {
  if (hasClass(elem, cls)) {
    let newClass = " " + elem.className.replace(/[\t\r\n]/g, "") + " ";
    while (newClass.indexOf(" " + cls + " ") >= 0) {
      newClass = newClass.replace(" " + cls + " ", " ");
    }
    elem.className = newClass.replace(/^\s+|\s+$/g, "");
  }
}

export { addClass, removeClass };
```

## 78. 计算一个数字数组的标准差（Standard Deviation, SD）和平均值（mean）

```ts
/** 该函数返回一个对象，包含两个属性：SD（标准差）和 mean（平均值）。 */
export const calculateSD = (arr: number[]) => {
  const n = arr.length;
  const mean = arr.reduce((a, b) => a + b, 0) / n;
  return {
    SD: Math.sqrt(
      arr.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n
    ),
    mean,
  };
};
```

## 79. 接收一个包含 url 和可选 data 的对象，生成一个带有查询参数的 URL，输出该 URL，并将其返回。

```ts
export const getLink = ({
  url,
  data = {},
}: {
  url: string;
  data?: Record<string, any>;
}) => {
  // 使用模板字符串构建包含查询参数的 URL
  const href = `${url}?${stringify(data)}`;
  // 输出生成的 URL
  console.log(href);
  // 返回生成的 URL
  return href;
};
```

## 80. 验证输入值的长度是否在指定的范围内

```ts
/** 检查 value 的长度是否在 min 和 max 之间。
 * 如果长度不在范围内，返回一个被拒绝的 Promise，带有错误消息 message。
 * 如果长度在范围内，返回一个已解决的 Promise。
 */
export const Length = (
  min: number,
  max: number,
  message = `The length should be between ${min} and ${max}.`
) => {
  return (value: any) => {
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value.length < min || value.length > max) {
      return Promise.reject(message);
    }
    return Promise.resolve();
  };
};
```

## 81. 验证输入值是否符合特定的正则表达式模式

```ts
export const Pattern = (pattern: RegExp, message = "Incorrect pattern.") => {
  // 返回一个新的函数，这个函数接受一个参数 value
  return (value: any) => {
    // 使用正则表达式 pattern 测试 value
    if (!pattern.test(value)) {
      // 如果 value 不匹配 pattern，返回一个被拒绝的 Promise，拒绝的原因是 message
      return Promise.reject(message);
    }
    // 如果 value 匹配 pattern，返回一个被解决的 Promise
    return Promise.resolve();
  };
};
```

## 82. 返回一个用于验证日期范围的函数

```ts
/** DateRange 是一个导出的常量函数。
 * 它接受一个对象作为参数，该对象包含四个可选属性：start、end、earlyMessage 和 lateMessage。
 * start 和 end 是 Dayjs 类型的日期对象，分别表示日期范围的开始和结束。
 * earlyMessage 和 lateMessage 是字符串，分别表示日期超出范围时的错误消息。
 */
export const DateRange = ({
  start,
  end,
  earlyMessage,
  lateMessage,
}: {
  start?: Dayjs;
  end?: Dayjs;
  earlyMessage?: string;
  lateMessage?: string;
}) => {
  // DateRange 返回一个函数，该函数接受一个 Dayjs 类型的 value 作为参数。
  return (value: Dayjs) => {
    /** 首先检查 start 是否存在且 value 是否早于 start。如果是，则返回一个被拒绝的 Promise，并带有 earlyMessage。
     * 然后检查 end 是否存在且 value 是否晚于 end。如果是，则返回一个被拒绝的 Promise，并带有 lateMessage。
     * 如果 value 在 start 和 end 范围内（或没有设置 start 和 end），则返回一个已解决的 Promise。
     */
    if (start && value.isBefore(start)) {
      return Promise.reject(earlyMessage);
    }
    if (end && value.isAfter(end)) {
      return Promise.reject(lateMessage);
    }
    return Promise.resolve();
  };
};
```

## 83. 将输入字符串转换为 PascalCase（即每个单词的首字母大写，其他字母小写，并且去掉所有的空格和下划线）。

```ts
export function pascalize(str: string) {
  // 匹配字符串开头的所有下划线，并将其存储在 prefix 变量中
  const prefix = str.match(/^_*/g)?.[0] ?? "";
  return (
    prefix +
    str
      .replace(/^_*/g, "") // 去掉开头的所有下划线
      .replace(/([A-Z])/g, "_$1") // 在每个大写字母前加下划线
      .toLowerCase() // 将整个字符串转换为小写
      .replace(/(^|_)(\w)/g, (_, __, c) => c.toUpperCase()) // 将每个单词的首字母大写
      .replace(/\s+/g, "")
  ) // 去掉所有空格
    .replace(/\s+/g, "");
}
```

## 84. 将输入字符串转换为 camelCase（即首字母小写，后续每个单词的首字母大写，去掉所有的空格和下划线）。

```ts
export function camelize(str: string) {
  const prefix = str.match(/^_*/g)?.[0] ?? "";
  return (
    prefix +
    str
      .replace(/([A-Z])/g, (letter, index) => {
        return index === 0 ? letter : `_${letter}`;
      })
      .replace(/^_*/g, "")
      .toLowerCase()
      .replace(/_+[^_]/g, (matched) => {
        return matched.replace(/_/g, "").toUpperCase();
      })
      .replace(/\s+/g, "")
  );
}
```

## 85. 将输入字符串转换为 snake_case（即所有字母小写，单词之间用下划线分隔）。

```ts
export function snakeize(str: string) {
  const prefix = str.match(/^_*/g)?.[0] ?? "";
  return (
    prefix +
    str
      .replace(/^_*/g, "")
      .replace(/([A-Z])/g, "_$1")
      .toLowerCase()
      .replace(/\s+/g, "")
  );
}
```

## 86. 将输入字符串转换为 kebab-case（即所有字母小写，单词之间用连字符 - 分隔）。

```ts
export function kebabize(str: string) {
  const prefix = str.match(/^_*/g)?.[0] ?? "";
  return (
    prefix +
    str
      .replace(/^_*/g, "")
      .replace(/([A-Z])/g, "-$1")
      .toLowerCase()
      .replace(/\s+/g, "")
  );
}
```

## 87. utc 国标时间转为 utc-8 北京时间

```ts
/*
 * utc转北京时间
 */
function utctobeijing(utc_datetime) {
  // 转为正常的时间格式 年-月-日 时:分:秒
  let new_datetime =
    utc_datetime.split("T")[0] + " " + utc_datetime.split("T")[1].split(".")[0];

  // 处理成为时间戳
  let timestamp = new Date(new_datetime.replace(/-/g, "/")).getTime();
  timestamp = timestamp / 1000;
  // 增加8个小时，北京时间比utc时间多八个时区
  timestamp = timestamp + 8 * 60 * 60;

  // 时间戳转为时间
  let date = new Date(parseInt(timestamp) * 1000);
  let YY = date.getFullYear() + "-";
  let MM =
    (date.getMonth() + 1 < 10
      ? "0" + (date.getMonth() + 1)
      : date.getMonth() + 1) + "-";
  let DD = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
  let hh =
    (date.getHours() < 10 ? "0" + date.getHours() : date.getHours()) + ":";
  let mm =
    (date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes()) +
    ":";
  let ss = date.getSeconds() < 10 ? "0" + date.getSeconds() : date.getSeconds();
  return YY + MM + DD + " " + hh + mm + ss;
}

/*
 * 执行方法测试
 */
var utc_datetime = "2021-04-19T01:38:32.000Z";
console.log(utctobeijing(utc_datetime));
```

## 88. CSS 穿透覆盖默认样式

```css
/* 需要通过 input，type="file"来上传文件，而这个 input 的默认样式，可以说是非常地丑。所以我们希望通过一张图片，与这个 input 大小一样，位置一致地盖在上面。这个时候，显然，这个时候点击图片，input 是不会起作用的。就是因为 img 隔绝了 click 的穿透，而我们希望的是，这个 img 只是视觉上遮挡了 input 的样式，但是点击的时候还是点击到 input。所以，只要让 img 可穿透即可。 */
img {
  pointer-events: none;
}
```

## 89. 实现自定义原生 select 控件的样式

```css
/* 于 select 移动端原生样式很丑，但是原生弹出效果是符合我们设计的原则。直接修改 select 的样式的时候，一个奇怪的现象出现了，在 chrome 上调试的时候，自己定义的样式起了作用，在 Android 手机上也起了作用，但是到了 ios 手机上就不行了，典型的不兼容问题，这个时候禁用原生的样式即可。 */
select {
  -webkit-appearance: none;
}
```

## 90. 文本溢出处理

```css
/* 移动设备相对来说页面较小，很多时候显示的一些信息都需要省略部分。最常见的是单行标题溢出省略，多行详情介绍溢出省略。现在都用框架开发了，这种建议需求建议形成一个基础组件，方便快捷。 */
/* 单行 */
.single {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
/* 多行 */
.more {
  display: -webkit-box !important;
  overflow: hidden;
  text-overflow: ellipsis;
  work-break: break-all;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2; //指定行数
}
```

## 91. 开启弹性滚动

```css
/* Android 不支持原生的弹性滚动，但可以借助第三方库 iScroll 来实现。 */
body {
  overflow: scroll;
  -webkit-overflow-scrolling: touch;
}
```

## 92. 像素边框设置

```css
/* 很多时候，想保持边框的大小在任何设置上都是 1px，但是因为 1px 使用 2dp 渲染，也就是说会显示为 2px 大小。所以，要采用 css3 缩放一下。 */
.folder li {
  position: relative;
  padding: 5px;
}
.folder li + li:before {
  position: absolute;
  top: -1px;
  left: 0;
  content: " ";
  width: 100%;
  height: 1px;
  border-top: 1px solid #ccc;
  -webkit-transform: scaleY(0.5);
}
```

## 93. 防止鼠标选中事件

```html
<!-- 元素添加了onslectstart="return false",就可以防止鼠标选中事件。 -->
<div class="mask" onselectstart="return false"></div>
<div class="link">
  <a href="javascrip;;">登录</a>
</div>
```

## 94. 给动态添加的元素绑定事件

```js
// 利用时间代理达到这个效果即可
// jquery中的写法
// 第一个参数表示的是对应事件，第二个是需要绑定事件的元素的id或class，第三个是绑定的对应的事件函数名
$(document).on("click", ".large", slide);
```

## 95. 兼容 IE 浏览器的透明度处理

```css
.ui {
  width: 100%;
  height: 100%;
  opacity: 0.4;
  /* 兼容IE浏览器的处理 */
  filter: Alpha(opacity=40);
}
```

## 96. 常用的全屏居中 JS 函数

```ts
//获取元素
function getElement(ele) {
  return document.getElementById(ele);
}
//自动居中函数
function autoCenter(el) {
  var bodyX = document.documentElement.offsetWidth || document.body.offsetWidth;
  var bodyY =
    document.documentElement.offsetHeight || document.body.offsetHeight;

  var elementX = el.offsetWidth;
  var elementY = el.offsetHeight;

  el.style.left = (bodyX - elementX) / 2 + "px";
  el.style.top = (bodyY - elementY) / 2 + "px";
}
```

## 97. 常用的全屏居中 CSS 函数

```css
body {
  height: 100vh;
  text-align: center;
  line-height: 100vh;
}
```

## 98. 在输入框输入完内容并按回车的时候进行判断

```html
<!-- 比如说输入完 11000 在按下回车的时候。 -->
<input type="textbox" id="textbox1" onkeypress="CheckInfo" />

<script language="javascript" type="text/javascript">
  function CheckInfo() {
    if (event.keyCode == 13) {
      alert(textbox1.text);
    }
  }
</script>
```

## 99. 判断日期是否有效

```ts
// 允许自定义日期格式并进行日期有效性的校验。
function isValidDate(value, userFormat) {
  // Set default format if format is not provided
  userFormat = userFormat || "mm/dd/yyyy";

  // Find custom delimiter by excluding
  // month, day and year characters
  var delimiter = /[^mdy]/.exec(userFormat)[0];

  // Create an array with month, day and year
  // so we know the format order by index
  var theFormat = userFormat.split(delimiter);

  // Create array from user date
  var theDate = value.split(delimiter);

  function isDate(date, format) {
    var m,
      d,
      y,
      i = 0,
      len = format.length,
      f;
    for (i; i < len; i++) {
      f = format[i];
      if (/m/.test(f)) m = date[i];
      if (/d/.test(f)) d = date[i];
      if (/y/.test(f)) y = date[i];
    }
    return (
      m > 0 &&
      m < 13 &&
      y &&
      y.length === 4 &&
      d > 0 &&
      // Check if it's a valid day of the month
      d <= new Date(y, m, 0).getDate()
    );
  }

  return isDate(theDate, theFormat);
}

// eg:
isValidDate("dd-mm-yyyy", "31/11/2012");
```

## 100. 获取一组元素的最大宽度或高度

```ts
// 动态排版的开发人员非常有用
var getMaxHeight = function ($elms) {
  var maxHeight = 0;
  $elms.each(function () {
    // In some cases you may want to use outerHeight() instead
    var height = $(this).height();
    if (height > maxHeight) {
      maxHeight = height;
    }
  });
  return maxHeight;
};
// eg:
$(elements).height(getMaxHeight($(elements)));
```

## 101. 高亮文本

```ts
// 自己定义高亮的样式, 创建自己的文本高亮插件。
function highlight(text, words, tag) {
  // Default tag if no tag is provided
  tag = tag || "span";

  var i,
    len = words.length,
    re;
  for (i = 0; i < len; i++) {
    // Global regex to highlight all matches
    re = new RegExp(words[i], "g");
    if (re.test(text)) {
      text = text.replace(re, "<" + tag + ">$&</" + tag + ">");
    }
  }

  return text;
}

// 取消高亮的函数
function unhighlight(text, tag) {
  // Default tag if no tag is provided
  tag = tag || "span";
  var re = new RegExp("(<" + tag + ".+?>|</" + tag + ">)", "g");
  return text.replace(re, "");
}

// eg:
$("p").html(
  highlight(
    $("p").html(), // the text
    ["foo", "bar", "baz", "hello world"], // list of words or phrases to highlight
    "strong" // custom tag
  )
);
```

## 102. 文字动效

```ts
// jQuery插件代码来达到这个效果。当然你需要结合一个CSS3 transition样式来达到更好的效果。
$.fn.animateText = function (delay, klass) {
  var text = this.text();
  var letters = text.split("");

  return this.each(function () {
    var $this = $(this);
    $this.html(text.replace(/./g, "<span>$&</span>"));
    $this.find("span.letter").each(function (i, el) {
      setTimeout(function () {
        $(el).addClass(klass);
      }, delay * i);
    });
  });
};

// eg:
$("p").animateText(15, "foo");
```

## 103. 逐个隐藏元素

```ts
// 这个jQuery插件可以根据你设置的步长（间隔时间）来逐个隐藏一组元素。在列表元素的重新加载中使用，可以达到很好的效果。
$.fn.fadeAll = function (ops) {
  var o = $.extend(
    {
      delay: 500, // delay between elements
      speed: 500, // animation speed
      ease: "swing", // other require easing plugin
    },
    ops
  );
  var $el = this;
  for (var i = 0, d = 0, l = $el.length; i < l; i++, d += o.delay) {
    $el.eq(i).delay(d).fadeIn(o.speed, o.ease);
  }
  return $el;
};
// eg:
$(elements).fadeAll({ delay: 300, speed: 300 });
```

## 104. 限制文本字数

```ts
// 允许你根据给定的字符长度截取文本，如果文本被截取，那么它的后面会自动带上省略号。
function excerpt(str, nwords) {
  var words = str.split(" ");
  words.splice(nwords, words.length - 1);
  return words.join(" ") + (words.length !== str.split(" ").length ? "…" : "");
}
```

## 105. 判断相应式布局中当前适配度

```ts
// 目前很多设计已经采用了响应式布局来适配网站或应用在不同设备上的显示。你经常需要在代码中判断当前处于哪一个屏幕适配度下
function isBreakPoint(bp) {
  // The breakpoints that you set in your css
  var bps = [320, 480, 768, 1024];
  var w = $(window).width();
  var min, max;
  for (var i = 0, l = bps.length; i < l; i++) {
    if (bps[i] === bp) {
      min = bps[i - 1] || 0;
      max = bps[i];
      break;
    }
  }
  return w > min && w <= max;
}

// eg:
if (isBreakPoint(320)) {
  // breakpoint at 320 or less
}
if (isBreakPoint(480)) {
  // breakpoint between 320 and 480
}
```

## 106. 全局计数

```ts
// 记录用户在当前页面上点击某一个按钮的次数，这时你可以使用jQuery的.data()函数来处理：
$(element)
  .data("counter", 0) // begin counter at zero
  .click(function () {
    var counter = $(this).data("counter"); // get
    $(this).data("counter", counter + 1); // set
    // do something else...
  });
```

## 107. 嵌入优酷视频

```ts
function embedYouku(link, ops) {

  var o = $.extend({
    width: 480,
    height: 320,
    params: ''
  }, ops);

  var id = /\?v\=(\w+)/.exec(link)[1];

  return '<embed allowFullScreen="true" id="embedid"  quality="high" width="'+o.width+'" height="'+o.height+'" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash" src="'+id+'?'+o.ops'"';
}

// eg:
embedYouku(
  'http://static.youku.com/v/swf/qplayer.swf',
  {'winType=adshow&VideoIDS=XMTE3NzQ0NTky&isAutoPlay=false&isShowRelatedVideo=false'}
);
```

## 108. 创建动态菜单或下拉列表

```ts
// 动态地创建菜单、下拉列表或列表项。下面是一段最基础的代码实现上面的功能，你可以根据实际需要进行相应的扩展。
function makeMenu(items, tags) {
  tags = tags || ["ul", "li"]; // default tags
  var parent = tags[0];
  var child = tags[1];

  var item,
    value = "";
  for (var i = 0, l = items.length; i < l; i++) {
    item = items[i];
    // Separate item and value if value is present
    if (/:/.test(item)) {
      item = items[i].split(":")[0];
      value = items[i].split(":")[1];
    }
    // Wrap the item in tag
    items[i] =
      "<" +
      child +
      " " +
      (value && 'value="' + value + '"') +
      ">" + // add value if present
      item +
      "</" +
      child +
      ">";
  }

  return "<" + parent + ">" + items.join("") + "</" + parent + ">";
}

// eg:
// Dropdown select month
makeMenu(
  ["January:JAN", "February:FEB", "March:MAR"], // item:value
  ["select", "option"]
);

// List of groceries
makeMenu(["Carrots", "Lettuce", "Tomatos", "Milk"], ["ol", "li"]);
```

## 109. 序列化

```ts
//  将传入对象 obj 的所有值转换为字符串，并返回一个新的对象，其中所有值都是字符串。
const stringify = (obj: Record<string, any>) => {
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] === "object") {
      obj[key] = JSON.stringify(obj[key]);
    } else {
      obj[key] = obj[key] + "";
    }
  });
  return { ...obj };
};
```

## 110. 处理 URL 查询参数中的 opener 值，并提供了一些相关的计算属性。

主要功能是从 URL 查询参数中提取 opener 值，并基于此值计算两个相关的属性 self 和 child。

```ts
/** QUERY_KEY 是一个导出的常量，表示查询参数的键名 'opener'。
 * PAGE_ID_START 是一个常量，表示一个非常小的整数值（JavaScript 中最小的安全整数）。
 */
export const QUERY_KEY = "opener";
const PAGE_ID_START = Number.MIN_SAFE_INTEGER;

/** 该函数用于从当前页面的 URL 查询参数中提取 opener 的值。
 * 如果 location.search 为空（即 URL 中没有查询参数），则返回 PAGE_ID_START。
 * 否则，解析查询参数，找到键为 opener 的参数值。
 * 如果找不到 opener 参数，则返回 PAGE_ID_START。
 * 如果找到，则返回其对应的数值。
 */

function extractOpener() {
  if (!location.search) return PAGE_ID_START;
  const found = location.search
    .slice(1)
    .split("&")
    .map((part) => part.split("="))
    .find(([k]) => k === QUERY_KEY);
  if (!found) return PAGE_ID_START;
  return +found[1];
}

/** pageid 对象包含三个属性：
 * opener：调用 extractOpener 函数的结果，即从 URL 查询参数中提取的 opener 值。
 * self：一个 getter 属性，返回 opener 值加 1。
 * child：一个 getter 属性，返回 self 值加 1。
 */

const pageid = {
  opener: extractOpener(),
  get self() {
    return this.opener + 1;
  },
  get child() {
    return this.self + 1;
  },
};

export default pageid;
```

## 111. 动态加载 JS 文件

```ts
/** 在一些特殊的场景下，特别是一些库和框架的开发中，我们有时会去动态的加载JS文件并执行，下面是利用Promise进行了简单的封装。
 * 上面代码核心有两点，一是利用Promise处理异步的逻辑，二是利用script标签进行js的加载并执行。
 */
function loadJS(files, done) {
  // 获取head标签
  const head = document.getElementsByTagName("head")[0];
  Promise.all(
    files.map((file) => {
      return new Promise((resolve) => {
        // 创建script标签并添加到head
        const s = document.createElement("script");
        s.type = "text/javascript";
        s.async = true;
        s.src = file;
        // 监听load事件，如果加载完成则resolve
        s.addEventListener("load", (e) => resolve(), false);
        head.appendChild(s);
      });
    })
  ).then(done); // 所有均完成，执行用户的回调事件
}

loadJS(["test1.js", "test2.js"], () => {
  // 用户的回调逻辑
});
```

## 112. 实现模板引擎

```ts
/** 下面示例用了极少的代码实现了动态的模板渲染引擎，不仅支持普通的动态变量的替换，还支持包含for循环，if判断等的动态的JS语法逻辑， */
// 这是包含了js代码的动态模板
var template =
  "My avorite sports:" +
  "<%if(this.showSports) {%>" +
  "<% for(var index in this.sports) {   %>" +
  "<a><%this.sports[index]%></a>" +
  "<%}%>" +
  "<%} else {%>" +
  "<p>none</p>" +
  "<%}%>";
// 这是我们要拼接的函数字符串
const code = `with(obj) {
  var r=[];
  r.push("My avorite sports:");
  if(this.showSports) {
    for(var index in this.sports) {   
      r.push("<a>");
      r.push(this.sports[index]);
      r.push("</a>");
    }
  } else {
    r.push("<span>none</span>");
  }
  return r.join("");
}`;
// 动态渲染的数据
const options = {
  sports: ["swimming", "basketball", "football"],
  showSports: true,
};
// 构建可行的函数并传入参数，改变函数执行时this的指向
result = new Function("obj", code).apply(options, [options]);
console.log(result);
```

## 113. 利用 reduce 进行数据结构的转换

```ts
/** 有时候前端需要对后端传来的数据进行转换，以适配前端的业务逻辑，或者对组件的数据格式进行转换再传给后端进行处理，而reduce是一个非常强大的工具。 */
const arr = [
  { classId: "1", name: "张三", age: 16 },
  { classId: "1", name: "李四", age: 15 },
  { classId: "2", name: "王五", age: 16 },
  { classId: "3", name: "赵六", age: 15 },
  { classId: "2", name: "孔七", age: 16 },
];

groupArrayByKey(arr, "classId");

function groupArrayByKey(arr = [], key) {
  return arr.reduce(
    (t, v) => (!t[v[key]] && (t[v[key]] = []), t[v[key]].push(v), t),
    {}
  );
}
```

## 114. 添加默认值

```ts
/** 有时候一个方法需要用户传入一个参数，通常情况下我们有两种处理方式，如果用户不传，我们通常会给一个默认值，亦或是用户必须要传一个参数，不传直接抛错。 */
function double() {
  return value * 2;
}

// 不传的话给一个默认值0
function double(value = 0) {
  return value * 2;
}

// 用户必须要传一个参数，不传参数就抛出一个错误

const required = () => {
  throw new Error("This function requires one parameter.");
};
function double(value = required()) {
  return value * 2;
}

double(3); // 6
double(); // throw Error
```

## 115. 函数只执行一次

```ts
/** 有些情况下我们有一些特殊的场景，某一个函数只允许执行一次，或者绑定的某一个方法只允许执行一次。*/
export function once(fn) {
  // 利用闭包判断函数是否执行过
  let called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}
```

## 116. 实现 Curring

```ts
/** JavaScript的柯里化是指将接受多个参数的函数转换为一系列只接受一个参数的函数的过程。这样可以更加灵活地使用函数，减少重复代码，并增加代码的可读性
 * 通过柯里化，我们可以将一些常见的功能模块化，例如验证、缓存等等。这样可以提高代码的可维护性和可读性，减少出错的机会。
 */
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

function add(x, y) {
  return x + y;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)); // 输出 3
console.log(curriedAdd(1, 2)); // 输出 3
```

## 117. 实现单例模式

```ts
/** JavaScript的单例模式是一种常用的设计模式，它可以确保一个类只有一个实例，并提供对该实例的全局访问点，在JS中有广泛的应用场景，如购物车，缓存对象，全局的状态管理等等。 */
let cache;
class A {
  // ...
}

function getInstance() {
  if (cache) return cache;
  return (cache = new A());
}

const x = getInstance();
const y = getInstance();

console.log(x === y); // true
```

## 118. 实现 CommonJs 规范

```ts
/** CommonJS规范的核心思想是将每个文件都看作一个模块，每个模块都有自己的作用域，其中的变量、函数和对象都是私有的，不能被外部访问。要访问模块中的数据，必须通过导出（exports）和导入（require）的方式。
 * 上面对CommonJs规范进行了简单的实现，核心解决了作用域的隔离，并提供了Myrequire方法进行方法和属性的加载
 */
// id：完整的文件名
const path = require("path");
const fs = require("fs");
function Module(id) {
  // 用来唯一标识模块
  this.id = id;
  // 用来导出模块的属性和方法
  this.exports = {};
}

function myRequire(filePath) {
  // 直接调用Module的静态方法进行文件的加载
  return Module._load(filePath);
}

Module._cache = {};
Module._load = function (filePath) {
  // 首先通过用户传入的filePath寻址文件的绝对路径
  // 因为再CommnJS中，模块的唯一标识是文件的绝对路径
  const realPath = Module._resoleveFilename(filePath);
  // 缓存优先，如果缓存中存在即直接返回模块的exports属性
  let cacheModule = Module._cache[realPath];
  if (cacheModule) return cacheModule.exports;
  // 如果第一次加载，需要new一个模块，参数是文件的绝对路径
  let module = new Module(realPath);
  // 调用模块的load方法去编译模块
  module.load(realPath);
  return module.exports;
};

// node文件暂不讨论
Module._extensions = {
  // 对js文件处理
  ".js": handleJS,
  // 对json文件处理
  ".json": handleJSON,
};

function handleJSON(module) {
  // 如果是json文件，直接用fs.readFileSync进行读取，
  // 然后用JSON.parse进行转化，直接返回即可
  const json = fs.readFileSync(module.id, "utf-8");
  module.exports = JSON.parse(json);
}

function handleJS(module) {
  const js = fs.readFileSync(module.id, "utf-8");
  let fn = new Function(
    "exports",
    "myRequire",
    "module",
    "__filename",
    "__dirname",
    js
  );
  let exports = module.exports;
  // 组装后的函数直接执行即可
  fn.call(
    exports,
    exports,
    myRequire,
    module,
    module.id,
    path.dirname(module.id)
  );
}

Module._resolveFilename = function (filePath) {
  // 拼接绝对路径，然后去查找，存在即返回
  let absPath = path.resolve(__dirname, filePath);
  let exists = fs.existsSync(absPath);
  if (exists) return absPath;
  // 如果不存在，依次拼接.js,.json,.node进行尝试
  let keys = Object.keys(Module._extensions);
  for (let i = 0; i < keys.length; i++) {
    let currentPath = absPath + keys[i];
    if (fs.existsSync(currentPath)) return currentPath;
  }
};

Module.prototype.load = function (realPath) {
  // 获取文件扩展名，交由相对应的方法进行处理
  let extname = path.extname(realPath);
  Module._extensions[extname](this);
};
```

## 119. 递归获取对象属性

```ts
/** 如果让我挑选一个用的最广泛的设计模式，我会选观察者模式，如果让我挑一个我所遇到的最多的算法思维，那肯定是递归，递归通过将原始问题分割为结构相同的子问题，然后依次解决这些子问题，组合子问题的结果最终获得原问题的答案。 */
const user = {
  info: {
    name: "张三",
    address: { home: "Shaanxi", company: "Xian" },
  },
};

// obj是获取属性的对象，path是路径，fallback是默认值
function get(obj, path, fallback) {
  const parts = path.split(".");
  const key = parts.shift();
  if (typeof obj[key] !== "undefined") {
    return parts.length > 0
      ? get(obj[key], parts.join("."), fallback)
      : obj[key];
  }
  // 如果没有找到key返回fallback
  return fallback;
}

console.log(get(user, "info.name")); // 张三
console.log(get(user, "info.address.home")); // Shaanxi
console.log(get(user, "info.address.company")); // Xian
console.log(get(user, "info.address.abc", "fallback")); // fallback
```

## 120. 获取变量的类型

```ts
const getType = (variable) =>
  Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();

getType(""); // string
getType(0); // number
getType(); // undefined
getType(null); // null
getType({}); // object
getType([]); // array
getType(0); // number
getType(() => {}); // function
```

## 121. 检测对象是否为空

```ts
const isEmptyObject = (obj) =>
  Object.keys(obj).length === 0 && obj.constructor === Object;
```

## 122. 获得滚动条的滚动距离

```ts
function getScrollOffset() {
  if (window.pageXOffset) {
    return {
      x: window.pageXOffset,

      y: window.pageYOffset,
    };
  } else {
    return {
      x: document.body.scrollLeft + document.documentElement.scrollLeft,

      y: document.body.scrollTop + document.documentElement.scrollTop,
    };
  }
}
```

## 123. 获得视口的尺寸

```ts
function getViewportOffset() {
  if (window.innerWidth) {
    return {
      w: window.innerWidth,
      h: window.innerHeight
    }
  } else {
    // ie8及其以下
    if (document.compatMode === “BackCompat”) {
      // 怪异模式
      return {
        w: document.body.clientWidth,
        h: document.body.clientHeight
      }
    } else {
      // 标准模式
      return {
        w: document.documentElement.clientWidth,
        h: document.documentElement.clientHeight
      }
    }
  }
}
```

## 124. 接受一个返回 Promise 的函数数组，并按顺序执行这些 Promise。

```ts
/**
 * sequence 是一个泛型函数，默认类型参数 T 为 any。
 * 参数 promises 是一个函数数组，每个函数返回一个 Promise<T>。
 *
 * 工作原理：
 * sequence 函数会按顺序执行 promises 数组中的每个函数，确保每个 Promise 在前一个 Promise 解决后才会执行。
 * 最终返回一个包含所有 Promise 执行结果的 Promise。
 */
export function sequence<T = any>(
  promises: Array<() => Promise<T>>
): Promise<T> {
  /**
   * 使用 reduce 方法遍历 promises 数组。
   * reduce 的初始值是一个已解决的 Promise (Promise.resolve())，类型为 Promise<T>。
   * 对于每个 current 函数，调用 prev.then(current)，这会在前一个 Promise 解决后执行当前的 Promise。
   */
  return promises.reduce((prev, current) => {
    return prev.then(current);
  }, Promise.resolve() as Promise<T>);
}

// 示例
const p1 = () => Promise.resolve(1);
const p2 = () => Promise.resolve(2);
const p3 = () => Promise.resolve(3);

sequence([p1, p2, p3]).then((result) => {
  console.log(result); // 输出 3
});
```

## 125. 将一个使用回调函数的异步函数转换为返回 Promise 的函数。

```ts
/** 工作原理
 * promisify 函数将一个使用回调函数的异步函数转换为返回 Promise 的函数。
 * 当调用返回的函数时，它会返回一个 Promise，并在异步操作完成时解决该 Promise。
 */

// promisify 是一个泛型函数，类型参数 T 表示回调函数返回的结果类型。
// 参数 fn 是一个函数，它接受任意数量的参数，并且最后一个参数是一个回调函数。
// 返回值是一个函数，这个函数接受任意数量的参数，并返回一个 Promise<T>。
export function promisify<T>(
  fn: (...args: Array<any>) => void
): (...args: any) => Promise<T> {
  // 返回的函数使用 ...args 收集所有传入的参数。
  // 返回一个新的 Promise<T>，在 Promise 的构造函数中调用 fn，并传入所有参数和一个回调函数。
  // 回调函数接受一个参数 result，并调用 resolve(result) 来解决 Promise。
  return function (...args) {
    return new Promise<T>((resolve) => {
      fn(...args, (result: T) => {
        resolve(result);
      });
    });
  };
}
```

## 126. 处理响应对象中的错误信息。如果响应对象中包含错误代码或返回码，则调用回调函数并抛出错误；否则，返回响应对象。

```ts
/**
 * 该函数用于检查响应对象中的错误代码或返回码。
 * 如果响应对象中包含错误代码或返回码，则调用回调函数（如果提供），并抛出错误。
 * 如果响应对象中没有错误代码或返回码，则返回响应对象。
 */

// errorHandle 是一个泛型函数，类型参数 T 约束为一个包含可选属性 code、ret、msg 和 message 的对象。
// 参数 res 是类型为 T 的响应对象。
// 参数 callback 是一个可选的回调函数，接受一个字符串参数 msg。
// 返回值类型为 T 或 never，表示函数要么返回 res，要么抛出错误。
export function errorHandle<
  T extends {
    code?: number;
    ret?: number;
    msg?: string;
    message?: string;
  }
>(res: T, callback?: (msg: string) => void): T | never {
  // 首先检查 res.code 和 res.ret 是否都不等于 0。
  // 如果条件为真，表示存在错误：
  // 如果提供了 callback，则调用它，并传入错误信息（res.msg 或 res.message，如果都不存在则传入空字符串）。
  // 抛出一个新的 Error 对象，错误信息为 res.msg 或 res.message。
  // 如果条件为假，表示没有错误：
  // 返回 res。
  if (res.code !== 0 && res.ret !== 0) {
    callback && callback(res.msg || res.message || "");
    throw new Error(res.msg || res.message);
  } else {
    return res;
  }
}
```

## 127. 该函数返回一个对象，该对象包含两个方法：increment 和 reset。

```ts
// 这是一个匿名函数，并将其赋值给 createIdIncrementor 常量。
// 该函数接受一个可选参数 id，默认值为 0。
export const createIdIncrementor = function (id = 0) {
  // 该函数返回一个对象，该对象包含两个方法：increment 和 reset。
  return {
    // increment 方法返回当前的 id 值，然后将 id 增加 1。
    // 例如，如果 id 当前为 0，调用 increment 后返回 0，然后 id 变为 1。
    increment() {
      return id++;
    },
    // reset 方法将 id 重置为传入的 value 值，默认值为 0。
    // 例如，调用 reset(5) 后，id 将被设置为 5。
    reset(value = 0) {
      id = value;
    },
  };
};

// 示例
const idIncrementor = createIdIncrementor();
console.log(idIncrementor.increment()); // 输出: 0
console.log(idIncrementor.increment()); // 输出: 1
idIncrementor.reset(10);
console.log(idIncrementor.increment()); // 输出: 10
```

## 128. 该函数接受一个 delay 参数（以毫秒为单位），并返回一个 Promise<void>。这个 Promise 在指定的延迟时间后被解决（resolved）。

```ts
/** 步骤:sleep 函数接受一个 delay 参数。
 * 返回一个新的 Promise<void> 对象。
 * 在 Promise 的执行函数中，调用 setTimeout，并传入一个回调函数和延迟时间 delay。
 * setTimeout 在指定的延迟时间后执行回调函数，回调函数调用 resolve()，从而解决（resolve）这个 Promise。
 */

// 创建一个延迟效果，可以在异步代码中使用 await sleep(delay) 来暂停执行一段时间。
export function sleep(delay: number) {
  return new Promise<void>((resolve) => {
    setTimeout(() => {
      resolve();
    }, delay);
  });
}
```

## 129. 防抖处理

debounce 函数的作用是创建一个防抖函数，该函数在指定的延迟时间内忽略后续的调用，直到延迟时间结束后才执行最后一次调用。如果 immediate 参数为 true，则在第一次调用时立即执行函数，而不是等待延迟时间结束。

```ts
// debounce 是一个泛型函数，接受一个函数 fn、一个延迟时间 delay（以毫秒为单位）和一个可选的 immediate 参数。
// immediate 参数默认为 false，表示是否立即执行函数。
export function debounce<T extends (...args: any) => void>(
  this: any,
  fn: T,
  delay: number,
  immediate = false
): T {
  // timeout 用于存储 setTimeout 的返回值，以便后续可以清除定时器。
  let timeout: any = null;

  // nFn 是实际返回的防抖函数，它接受任意数量的参数。
  const nFn = (...args: any) => {
    // later 函数在延迟时间结束后执行。如果 immediate 为 false，则调用原始函数 fn。
    const later = () => {
      timeout = null;
      if (!immediate) {
        fn.apply(this, args);
      }
    };

    // callNow 用于判断是否需要立即执行函数。如果 immediate 为 true 且 timeout 为 null，则立即执行。
    const callNow = immediate && !timeout;

    // 清除之前的定时器，并设置一个新的定时器。
    clearTimeout(timeout);
    timeout = setTimeout(later, delay);

    // 如果需要立即执行函数，则调用原始函数 fn。
    if (callNow) {
      fn.apply(this, args);
    }
  };
  // 返回防抖函数
  return nFn as unknown as T;
}
```

## 130. 节流处理

代码定义了一个 throttle 函数，用于限制某个函数在指定时间间隔内的调用频率。具体来说，它可以确保一个函数在一定时间内最多只会被调用一次。

```ts
/** 参数解释
 * func: 需要被节流的函数。
 * time: 节流的时间间隔，单位为毫秒。
 * immediate: 一个布尔值，表示是否立即执行函数。如果为 true，函数会立即执行，然后在指定时间内不再执行；如果为 false，函数会在指定时间后执行。
 */
/** 逻辑解释
 * 1. 立即执行模式 (immediate = true):
 * 使用 prevTime 记录上一次执行的时间。
 * 每次调用返回的函数时，检查当前时间与上一次执行时间的差值是否大于等于 time。
 * 如果是，则执行 func，并更新 prevTime。
 * 2. 延迟执行模式 (immediate = false):
 * 使用 timer 记录定时器。
 * 每次调用返回的函数时，检查 timer 是否存在。
 * 如果 timer 不存在，则执行 func，并设置一个定时器，在 time 毫秒后清除 timer。
 */
export function throttle<T extends (...args: any[]) => any>(
  this: any,
  func: T,
  time: number,
  immediate = false
) {
  // 如果 immediate 为 true，立即执行函数，然后在指定时间内不再执行
  if (immediate) {
    let prevTime = 0;
    return (...args: Parameters<T>) => {
      const nowTime = Date.now();
      if (nowTime - prevTime >= time) {
        func.apply(this, args);
        prevTime = nowTime;
      }
    };
  } else {
    // 如果 immediate 为 false，延迟执行函数
    let timer: any;
    return (...args: Parameters<T>) => {
      if (!timer) {
        func.apply(this, args);
        timer = setTimeout(() => {
          if (timer) clearInterval(timer);
          timer = null;
        }, time);
      }
    };
  }
}

// 示例
const throttledFunc = throttle(myFunction, 1000, true);
throttledFunc(); // 立即执行 myFunction
throttledFunc(); // 在 1000 毫秒内不会再次执行 myFunction
```

## 131. 生成一个带有可选参数的 OSS（对象存储服务）URL。它接受三个参数：url、resize 和 extParams，并根据这些参数返回一个完整的 URL。

getOssUrl 函数主要用于生成带有可选图像处理参数的完整 OSS URL。它根据传入的 url、resize 和 extParams 参数，动态生成符合要求的 URL。

```ts
/** 参数
 * url：一个字符串，表示需要处理的 URL。
 * resize（可选）：一个字符串数组，表示图像调整参数。
 * extParams（可选）：一个字符串，表示额外的参数。
 */

/** 逻辑
 * 1. **内部函数 resizeParams**：
 * 该函数用于生成图像处理参数字符串。
 * 如果 resize 和 extParams 都为空，则返回空字符串 ''。
 * 否则，初始化参数字符串 params 为 '?x-oss-process=image'。
 * 如果 resize 不为空，将其转换为字符串并添加到 params 中。
 * 如果 extParams 不为空，将其添加到 params 中。
 * 最终返回生成的参数字符串。
 * 2. 确定基础 OSS URL：
 * 根据 tw.polyfilled 的值，选择不同的基础 URL。如果 tw.polyfilled 为 true，则使用 https://storm-oss-cdn.topwidgets.com/，否则使用 oss://image。
 * 3. 生成完整的 OSS URL：
 * 将基础 URL、传入的 url 和生成的参数字符串拼接在一起，返回完整的 URL。
 */
export function getOssUrl(url: string, resize?: string[], extParams?: string) {
  const resizeParams = () => {
    if (!resize && !extParams) return "";

    const prefix = "?x-oss-process=image";

    let params = prefix;
    if (resize)
      if (resize) {
        params += `/resize,${resize.join(",")}`;
      }
    if (extParams) {
      params += extParams;
    }
    return params;
  };

  const ossUrl = tw.polyfilled
    ? "https://storm-oss-cdn.topwidgets.com/"
    : "oss://image";
  return ossUrl + url + resizeParams();
}

// 示例
getOssUrl("path/to/resource", ["w_100", "h_200"], "&quality=90");
// 返回 'https://storm-oss-cdn.topwidgets.com/path/to/resource?x-oss-process=image/resize,w_100,h_200&quality=90'

getOssUrl("path/to/resource");
// 返回 'https://storm-oss-cdn.topwidgets.com/path/to/resource'

getOssUrl("path/to/resource", ["w_100"]);
// 返回 'https://storm-oss-cdn.topwidgets.com/path/to/resource?x-oss-process=image/resize,w_100'
```

## 132. 导出传入的函数，使其可以在其他模块中被导入和使用。

这行代码声明了一个名为 getOssOriginUrl 的函数，并将其导出，使其可以在其他模块中被导入和使用。该函数接受一个参数 url，类型为字符串

```ts
export function getOssOriginUrl(url: string) {
  const ossUrl = "https://storm-oss-cdn.topwidgets.com/";
  // 将传入的 url 参数与 ossUrl 常量进行字符串拼接，并返回拼接后的完整 URL。
  return ossUrl + url;
}
```

## 133. 定义了一个名为 addBase64 的导出函数。该函数接受两个参数：url 和 ext，它们都是字符串类型。函数的作用是将传入的 url 和 ext 组合成一个 Base64 数据 URI，并返回这个字符串。

```ts
/** 工作原理
 * url 参数代表一个 Base64 编码的图像数据。
 * ext 参数代表图像的扩展名（例如 png、jpeg 等）。
 * 函数返回一个字符串，格式为 data:image/{ext};base64,{url}，这是一个标准的 Base64 数据 URI 格式，用于在网页中嵌入图像。
 */

export const addBase64 = (url: string, ext: string) => {
  return `data:image/${ext};base64,${url}`;
};
```

## 134.该函数接受一个字符串类型的参数 url，并返回该字符串的文件扩展名。如果无法提取扩展名，则返回默认值 'png'。

```ts
/** 工作原理
 * 使用 split('.') 方法将 url 按照 . 分隔成一个数组。
 * 使用 pop() 方法获取数组的最后一个元素，这个元素通常是文件的扩展名。
 * 如果 pop() 返回 undefined（即 url 中没有 .），则返回默认值 'png'。
 */
export const getExt = (url: string) => {
  // 将 url 按照 '.' 分隔成数组，并获取最后一个元素
  return url.split(".").pop() || "png";
};
```

## 135. 检测用户的系统是否处于暗色模式

```ts
/** 工作原理
 * 定义一个箭头函数 isDarkMode，它不接受任何参数。
 * 在函数体内，使用 window.matchMedia 方法来查询用户的系统配色方案。
 * window.matchMedia 方法接受一个媒体查询字符串作为参数，这里使用的是 '(prefers-color-scheme: dark)'，表示查询用户是否偏好暗色模式。
 * window.matchMedia 方法返回一个 MediaQueryList 对象，该对象有一个 matches 属性。
 * 如果 matches 属性为 true，则表示用户的系统处于暗色模式；否则，表示用户的系统不处于暗色模式。
 * 函数返回 matches 属性的值。
 *
 * 简而言之，这个函数返回一个布尔值，指示用户的系统是否处于暗色模式。
 */
export const isDarkMode = () => {
  // 使用 window.matchMedia 查询用户是否偏好暗色模式
  return window.matchMedia("(prefers-color-scheme: dark)").matches;

  // 如果用户的系统设置为暗色模式，调用 isDarkMode() 会返回 true。
  // 如果用户的系统设置为亮色模式，调用 isDarkMode() 会返回 false。
};
```

## 136. 用于生成一系列预定义的颜色，并且可以在需要时重置颜色序列。

```ts
/** ColorGenerator
 * 静态属性 colors: 这是一个包含颜色字符串的数组。每个字符串表示一种颜色的十六进制代码。
 * 实例属性 offset: 这是一个数字，用于跟踪当前颜色的索引。
 * 构造函数 constructor: 初始化 offset 为 0。
 *
 * 方法 getColor:
 * 计算当前颜色的索引 colorIndex，使用 offset 对颜色数组长度取模。
 * 增加 offset 的值。
 * 返回当前索引对应的颜色。
 *
 * 方法 reset:
 * 将 offset 重置为指定的值（默认为 0）。
 */

/** createColorGenerator
 * 这是一个工厂函数，用于创建并返回一个新的 ColorGenerator 实例。
 */
class ColorGenerator {
  static colors = [
    "#E8CBC0",
    "#9EA283",
    "#BDC7C6",
    "#F7EDE0",
    "#F1EAD4",
    "#F0EEEF",
    "#F7EDE0",
    "#D7B4A5",
    "#C5CCDC",
    "#E8CBC0",
    "#9EA283",
    "#BDC7C6",
  ];
  offset: number;
  constructor() {
    this.offset = 0;
  }
  getColor() {
    const colorIndex = this.offset % (ColorGenerator.colors.length - 1);
    this.offset++;
    return ColorGenerator.colors[colorIndex];
  }
  reset(value = 0) {
    this.offset = value;
  }
}
export function createColorGenerator() {
  return new ColorGenerator();
}

// 示例
const generator = createColorGenerator();
console.log(generator.getColor()); // 输出第一个颜色
console.log(generator.getColor()); // 输出第二个颜色
generator.reset(); // 重置 offset
console.log(generator.getColor()); // 再次输出第一个颜色
```

## 137. 获取视口的宽度和高度

这个函数主要用于获取当前视口的宽度和高度，优先使用 screen 对象的宽度和高度，如果不可用，则使用 document.documentElement 的宽度和高度。这样可以确保在不同的浏览器环境下都能正确获取视口尺寸。

```ts
/** 说明
 * 1. 函数定义:
 * getViewPort 是一个箭头函数，使用 export 导出，使其可以在其他模块中导入和使用。
 *
 * 2. 返回对象:
 * 该函数返回一个对象，该对象包含视口的宽度和高度。
 *
 * 3. 宽度计算:
 * width: screen.width || document.documentElement.clientWidth:
 * screen.width 返回屏幕的宽度（以像素为单位）。
 * 如果 screen.width 不可用，则使用 document.documentElement.clientWidth，它返回文档的根元素（通常是 <html> 元素）的宽度。
 *
 * 4. 高度计算:
 * height: screen.height || document.documentElement.clientHeight:
 * screen.height 返回屏幕的高度（以像素为单位）。
 * 如果 screen.height 不可用，则使用 document.documentElement.clientHeight，它返回文档的根元素的高度。
 */
export const getViewPort = () => {
  return {
    width: screen.width || document.documentElement.clientWidth,
    height: screen.height || document.documentElement.clientHeight,
  };
};

// 示例
const viewport = getViewPort();
console.log(viewport.width); // 输出视口的宽度
console.log(viewport.height); // 输出视口的高度
```

## 138. 两个用于管理 IntersectionObserver 的对象。用于观察 DOM 元素的可见性变化，并在元素进入或离开视口时执行回调函数。

```ts
/** 类型定义
 * Callback 是一个类型定义，表示一个接受 IntersectionObserverEntry 参数并返回 void 的函数。
 * bucket 是一个 WeakMap，用于存储 DOM 元素和对应的回调函数。
 */
type Callback = (entry: IntersectionObserverEntry) => void;
const bucket = new WeakMap<HTMLElement, Callback>();

/** createObserver
 * createObserver 是一个函数，接受 IntersectionObserverInit 类型的 options 参数，并返回一个对象。
 *
 * 该对象包含以下方法：
 * observer: 创建一个新的 IntersectionObserver 实例，并在元素进入或离开视口时执行回调。
 * observe(el, cb): 开始观察指定的 DOM 元素，并将回调函数存储在 bucket 中。
 * unobserve(el): 停止观察指定的 DOM 元素，并从 bucket 中删除回调函数。
 * takeRecords(): 获取 IntersectionObserver 的记录。
 */
export const createObserver = (options: IntersectionObserverInit) => {
  return {
    observer: new IntersectionObserver((entries) => {
      for (const entry of entries) {
        //执行回调
        bucket.get(entry.target as HTMLElement)?.(entry);
      }
    }, options),
    observe(el: HTMLElement, cb: Callback) {
      this.observer.observe(el);
      bucket.set(el, cb);
    },
    unobserve(el: HTMLElement) {
      this.observer.unobserve(el);
      bucket.delete(el);
    },
    takeRecords() {
      this.observer.takeRecords();
    },
  };
};
/** AdObserver
 * AdObserver 是一个对象，包含一个 IntersectionObserver 实例和一些方法。
 * 该对象的 observer 属性是一个 IntersectionObserver 实例，配置了 rootMargin 和 threshold。
 *
 * 该对象包含以下方法：
 * observe(el, cb): 开始观察指定的 DOM 元素，并将回调函数存储在 bucket 中。
 * unobserve(el): 停止观察指定的 DOM 元素，并从 bucket 中删除回调函数。
 * takeRecords(): 获取 IntersectionObserver 的记录。
 */
export const AdObserver = {
  observer: new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting) {
          //执行回调
          bucket.get(entry.target as HTMLElement)?.(entry);
        }
      }
    },
    {
      rootMargin: "0px 0px 0px 0px",
      threshold: [0],
    }
  ),
  observe(el: HTMLElement, cb: Callback) {
    this.observer.observe(el);
    bucket.set(el, cb);
  },
  unobserve(el: HTMLElement) {
    this.observer.unobserve(el);
    bucket.delete(el);
  },
  takeRecords() {
    this.observer.takeRecords();
  },
};
/** 总结
 * createObserver 函数和 AdObserver 对象都用于创建和管理 IntersectionObserver 实例。
 * 它们可以观察 DOM 元素的可见性变化，并在元素进入或离开视口时执行回调函数。
 * bucket 用于存储 DOM 元素和对应的回调函数，以便在元素状态变化时调用相应的回调。
 */
```

## 139. 计算给定数字数组的标准差（Standard Deviation, SD）和平均值（mean）。

```ts
// 这是一个导出的常量函数，接受一个数字数组 arr 作为参数。
export const calculateSD = (arr: number[]) => {
  // 获取数组的长度 n。
  const n = arr.length;
  // 使用 reduce 方法将数组中的所有元素求和，然后除以数组长度 n，得到平均值 mean。
  const mean = arr.reduce((a, b) => a + b, 0) / n;
  // 首先，使用 map 方法计算每个元素与平均值的差的平方。
  // 然后，使用 reduce 方法将这些平方值求和。
  // 接着，将求和结果除以数组长度 n，得到方差。
  // 最后，使用 Math.sqrt 方法计算方差的平方根，得到标准差 SD。
  return {
    // 返回一个对象，包含计算得到的标准差 SD 和平均值 mean。
    SD: Math.sqrt(
      arr.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n
    ),
    mean,
  };
};
```

## 140. 根据传入的图像路径和处理参数生成一个处理后的图像 URL，支持设置图像的格式、尺寸和透明度。

```ts
/** 接口
 * 定义了一个接口 OSSProcess，包含三个可选属性：
 * width：图像的宽度。
 * height：图像的高度。
 * alpha：是否包含 alpha 通道（透明度）。
 */
interface OSSProcess {
  width?: number;
  height?: number;
  alpha?: boolean;
}
/** 定义并导出一个名为 oss 的函数，接受两个参数：
 * path：字符串类型，表示图像的路径。
 * { width, height, alpha }：解构自 OSSProcess 接口的对象。
 */
export const oss = (path: string, { width, height, alpha }: OSSProcess) => {
  // 检查 path 是否为空或仅包含空白字符，如果是，则返回空字符串。
  if (!path?.trim()) {
    return "";
  }
  // 初始化处理字符串 process，以 ? 开头。
  let process = `?`;
  // 如果 alpha 为 true，则在 process 字符串中添加 .png&。
  if (alpha) process += ".png&";
  // 在 process 字符串中添加 x-oss-process=image/format,webp，将图像格式设置为 webp。
  process += "x-oss-process=image/format,webp";
  // 如果 width 和 height 都存在，则在 process 字符串中添加 /resize,m_mfit,h_${height},w_${width}，设置图像的宽度和高度。
  if (width && height) {
    process += `/resize,m_mfit,h_${height},w_${width}`;
  }
  // 如果 tw.polyfilled 为 true，则返回 https://oss.topwidgets.com/ 开头的 URL。
  // 否则，返回 oss://image/ 开头的 URL。
  // 在生成的 URL 中，使用 path.replace(/^\/?/, '') 去除路径开头的斜杠，并附加 process 字符串。

  // tw.polyfilled 类型为 boolean | undefined
  if (tw.polyfilled) {
    return `https://oss.topwidgets.com/${path.replace(/^\/?/, "")}${process}`;
  }
  return `oss://image/${path.replace(/^\/?/, "")}${process}`;
};
```

## 141. 解析当前应用程序 URL 中的查询数据。

这个函数的目的是从当前应用程序的 URL 查询参数中获取数据，并将其解析为指定的类型 T。如果解析失败，它会捕获错误并输出到控制台。

```ts
// 这是一个导出的常量函数 getQueryData，它是一个泛型函数，泛型类型参数为 T。
export const getQueryData = <T>() => {
  // 在 try 块中，函数尝试将 currentAppURL.queries?.data 解析为 JSON 对象，并将其转换为类型 T。currentAppURL.queries?.data 是一个可选链操作符，表示如果 queries 或 data 为 null 或 undefined，则不会抛出错误。
  try {
    return JSON.parse(currentAppURL.queries?.data) as T;
  } catch (e) {
    // 如果在解析过程中发生错误（例如，data 不是有效的 JSON 字符串），错误将被捕获，并通过 console.error 输出到控制台。
    console.error(e);
  }
};
```

## 142. 用于观察元素的可见性变化

这段代码通过调用 createObserver 函数并传入一个包含 rootMargin 配置的对象，创建了一个 WidgetObserver 常量。这个常量可以用于观察元素的可见性变化，rootMargin 属性定义了观察区域的边距。

```ts
// createObserver 是一个函数，它接受一个配置对象作为参数。在这个配置对象中，设置了 rootMargin 属性。
export const WidgetObserver = createObserver({
  // 这个配置对象包含一个 rootMargin 属性，其值为 '150px 0px 150px 0px'。rootMargin 是一个用来扩展或缩小 IntersectionObserver 的根边界的属性。它的值是一个包含四个值的字符串，分别表示上、右、下、左的边距。
  rootMargin: "150px 0px 150px 0px",
});
```

## 143. 用于在当前事件循环结束后、下一次重绘之前执行某些操作

waitNextTick 函数返回一个 Promise，该 Promise 会在下一次重绘之前被解决（resolved）。这通常用于在当前事件循环结束后、下一次重绘之前执行某些操作。

```ts
// waitNextTick 是一个箭头函数，它不接受任何参数，并返回一个新的 Promise 对象。
export const waitNextTick = () => {
  // 在 Promise 对象的构造函数中，传入了一个回调函数 res。这个回调函数会在 Promise 被解决（resolved）时调用。
  return new Promise((res) => {
    // 在 nextTick 的回调函数中，调用了 requestAnimationFrame 并传入了 res 作为回调函数。nextTick 通常用于在下一个事件循环中执行代码。
    nextTick(() => {
      // requestAnimationFrame 是一个浏览器 API，用于在下一次重绘之前执行回调函数。在这里，它会在下一次重绘之前调用 res，从而解决（resolve）这个 Promise。
      requestAnimationFrame(res);
    });
  });
};
```

## 144. 检查给定的语言 lang 是否在支持的语言列表 supportedLanguages 中。

检查给定的语言 lang 是否在支持的语言列表 supportedLanguages 中。如果在列表中，则返回该语言；否则，返回默认语言 'zh'。

```ts
/** 这行代码声明并导出一个名为 realLang 的箭头函数，使其可以在其他模块中被导入和使用。该函数接受两个参数：
 * supportedLanguages: 一个 Languages 类型的数组，表示支持的语言列表。
 * lang: 一个 Languages 类型的变量，表示当前语言。
 */
export const realLang = (
  supportedLanguages: Array<Languages>,
  lang: Languages
) => {
  /** 函数体包含一个 if 语句，用于检查 supportedLanguages 数组是否包含 lang：
   * 如果 supportedLanguages 数组包含 lang，则返回 lang。
   * 否则，返回 'zh'。
   */
  if (supportedLanguages.includes(lang)) {
    return lang;
  } else {
    return "zh";
  }
};
```

## 145. 格式化数值(根据数值的大小，将其格式化为不同的字符串表示形式。)

```ts
export const formatHotValue = (num: number) => {
  // 如果 num 小于 1000，函数直接返回 num，不进行任何格式化。
  if (num < 1000) {
    return num;
  }
  // 如果 num 介于 1000 和 100,000 之间，函数将 num 除以 1000，然后四舍五入到小数点后两位，再保留一位小数，并在末尾加上 K。例如，1500 会被格式化为 1.5K。
  if (num < 100_000) {
    return `${(Math.round((num / 1000) * 100) / 100).toFixed(1)}K`;
  }
  // 如果 num 大于等于 100,000，函数将 num 除以 10,000，然后四舍五入到小数点后两位，再保留两位小数，并在末尾加上 W。例如，150,000 会被格式化为 15.00W。
  return `${(Math.round((num / 10_000) * 100) / 100).toFixed(2)}W`;
};
```

## 146. 根据不同的语言环境格式化数值

```ts
import { getLocale } from "@/lang/tool";
/**
 * 该函数接受一个数值 num 作为参数。
 * 如果 num 小于 1000，返回原始数值和空单位。
 * 如果 num 介于 1000 和 1,000,000 之间，返回数值除以 10,000 后保留两位小数，并附加单位 K。
 * 如果 num 大于等于 1,000,000，返回数值除以 1,000,000 后保留两位小数，并附加单位 M。
 */
const formatNumberWithUnitEn = (num: number) => {
  if (num < 1000) {
    return {
      num,
      unit: "",
    };
  }
  if (num < 1_000_000) {
    return {
      num: (Math.round((num / 10000) * 100) / 100).toFixed(2),
      unit: "K",
    };
  }
  return {
    num: (Math.round((num / 1_000_000) * 100) / 100).toFixed(2),
    unit: "M",
  };
};
/**
 * 该函数接受一个数值 num 作为参数。
 * 如果 num 小于 10,000，返回原始数值和空单位。
 * 如果 num 介于 10,000 和 100,000,000 之间，返回数值除以 10,000 后保留两位小数，并附加单位 万。
 * 如果 num 大于等于 100,000,000，返回数值除以 100,000,000 后保留两位小数，并附加单位 亿。
 */
const formatNumberWithUnitZh = (num: number) => {
  if (num < 10000) {
    return {
      num,
      unit: "",
    };
  }
  if (num < 100_000_000) {
    return {
      num: (Math.round((num / 10000) * 100) / 100).toFixed(2),
      unit: "万",
    };
  }
  return {
    num: (Math.round((num / 100_000_000) * 100) / 100).toFixed(2),
    unit: "亿",
  };
};
/**
 * 该函数接受一个数值 num 作为参数。
 * 根据 getLocale() 函数返回的语言环境，调用相应的格式化函数。
 * 如果语言环境是 en，调用 formatNumberWithUnitEn 函数，否则调用 formatNumberWithUnitZh 函数。
 */
export const formatNumberWithUnit = (num: number) => {
  if (getLocale() === "en") {
    return formatNumberWithUnitEn(num);
  }
  return formatNumberWithUnitZh(num);
};
```

## 147. 验证器，用于检查输入值是否为空

这个验证器确保输入值不为空，并在验证失败时返回一个带有错误信息的被拒绝的 Promise。

```ts
// 接受一个可选参数 message，默认值为 'It is required.'。这个参数是当验证失败时返回的错误信息。
export const Required = (message = "It is required.") => {
  // 返回一个新的函数，这个新函数接受一个参数 value，表示要验证的值。
  return (value: any) => {
    // 在返回的函数内部：
    // 如果 value 是一个字符串，则调用 trim() 方法去除字符串两端的空白字符。
    // 检查 value 是否为 undefined、null 或空字符串 ''。
    // 如果 value 是上述任意一种情况，则返回一个被拒绝的 Promise，携带错误信息 message。
    // 否则，返回一个被解决的 Promise，表示验证通过。
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value === undefined || value === null || value === "") {
      return Promise.reject(message);
    }
    return Promise.resolve();
  };
};
```

## 148. 验证器，用于检查输入值是否在指定的范围内

这个验证器确保输入值在指定的范围内，并在验证失败时返回一个带有错误信息的被拒绝的 Promise。

```ts
/** 接受三个参数：
 * min：范围的最小值。
 * max：范围的最大值。
 * message：当验证失败时返回的错误信息，默认值为 value should be ranged between ${min} and ${max}.。
 */
export const Range = (
  min: number,
  max: number,
  message = `value should be ranged between ${min} and ${max}.`
) => {
  // 返回一个新的函数，这个新函数接受一个参数 value，表示要验证的值。
  return (value: any) => {
    /** 返回的函数内部：
     * 如果 value 是一个字符串，则调用 trim() 方法去除字符串两端的空白字符。
     * 检查 value 是否小于 min 或大于 max。
     * 如果 value 不在范围内，则返回一个被拒绝的 Promise，携带错误信息 message。
     * 否则，返回一个被解决的 Promise，表示验证通过。
     */
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value < min || value > max) {
      return Promise.reject(message);
    }
    return Promise.resolve();
  };
};
```

## 149. 日期范围验证器，用于检查输入的日期是否在指定的开始和结束日期之间。

这个验证器确保输入的日期在指定的开始和结束日期之间，并在验证失败时返回一个带有错误信息的被拒绝的 Promise。

```ts
/** 接受一个对象作为参数，该对象包含以下属性：
 * start：可选的开始日期，类型为 Dayjs。
 * end：可选的结束日期，类型为 Dayjs。
 * earlyMessage：可选的错误信息，当输入日期早于开始日期时返回。
 * lateMessage：可选的错误信息，当输入日期晚于结束日期时返回。
 */
export const DateRange = ({
  start,
  end,
  earlyMessage,
  lateMessage,
}: {
  start?: Dayjs;
  end?: Dayjs;
  earlyMessage?: string;
  lateMessage?: string;
}) => {
  // 返回一个新的函数，这个新函数接受一个参数 value，表示要验证的日期，类型为 Dayjs。
  return (value: Dayjs) => {
    /** 返回的函数内部：
     * 如果 start 存在并且 value 早于 start，则返回一个被拒绝的 Promise，携带错误信息 earlyMessage。
     * 如果 end 存在并且 value 晚于 end，则返回一个被拒绝的 Promise，携带错误信息 lateMessage。
     * 如果 value 在 start 和 end 之间（包括边界），则返回一个被解决的 Promise，表示验证通过。
     */
    if (start && value.isBefore(start)) {
      return Promise.reject(earlyMessage);
    }
    if (end && value.isAfter(end)) {
      return Promise.reject(lateMessage);
    }
    return Promise.resolve();
  };
};
```

## 150. 验证器工厂函数

用于表单验证等场景，确保输入值的长度在指定范围内。

```ts
/** 接受三个参数：
 * min：最小长度（number 类型）。
 * max：最大长度（number 类型）。
 * message：可选的错误消息（string 类型），默认值为 The length should be between ${min} and ${max}.。
 */
export const Length = (
  min: number,
  max: number,
  message = `The length should be between ${min} and ${max}.`
) => {
  // 返回一个新的函数，这个新函数接受一个参数 value，用于验证 value 的长度是否在 min 和 max 之间。
  return (value: any) => {
    /** 具体步骤如下：
     * 如果 value 是字符串类型，则去除其首尾的空白字符。
     * 检查 value 的长度是否小于 min 或大于 max。
     * 如果是，则返回一个被拒绝的 Promise，带有错误消息 message。
     * 如果不是，则返回一个被解决的 Promise。
     */
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value.length < min || value.length > max) {
      return Promise.reject(message);
    }
    return Promise.resolve();
  };
};
```

## 151. 验证器工厂函数

验证输入的字符串是否是一个有效的电子邮件地址。如果验证失败，会返回一个被拒绝的 Promise，并输出错误消息。F

```ts
/** 接受两个参数：
 * pattern：一个正则表达式（RegExp 类型），用于测试输入值是否匹配该模式。
 * message：一个可选的错误消息（string 类型），默认值为 'Incorrect pattern.'。
 */
export const Pattern = (pattern: RegExp, message = "Incorrect pattern.") => {
  // 返回一个新的函数，这个新函数接受一个参数 value，用于验证 value 是否匹配提供的正则表达式 pattern。
  return (value: any) => {
    /** 具体步骤如下：
     * 使用 pattern.test(value) 方法测试 value 是否匹配正则表达式 pattern。
     * 如果不匹配，则返回一个被拒绝的 Promise，带有错误消息 message。
     * 如果匹配，则返回一个被解决的 Promise。
     */
    if (!pattern.test(value)) {
      return Promise.reject(message);
    }
    return Promise.resolve();
  };
};

// 示例
const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const validateEmail = Pattern(emailPattern, "Invalid email address.");

validateEmail("test@example.com")
  .then(() => console.log("Valid email"))
  .catch((err) => console.log(err)); // 输出: Valid email

validateEmail("invalid-email")
  .then(() => console.log("Valid email"))
  .catch((err) => console.log(err)); // 输出: Invalid email address.
```
