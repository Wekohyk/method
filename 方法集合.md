# 方法目录 {ignore}

[toc]

## 1. 函数节流

```ts
/** 函数节流
 * [func 函数 wait 延迟执行毫秒数 type 1 表时间戳版，2 表定时器版]
 */
const throttle = function (func, wait, type) {
  let previous: number = 0;
  let timeout: number | null = null;

  return function () {
    let context = this;
    let args = arguments;
    if (type === 1) {
      let now = Date.now();
      if (now - previous > wait) {
        func.apply(context, args);
        previous = now;
      }
    } else if (type === 2) {
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null;
          func.apply(context, args);
        }, wait);
      }
    }
  };
};
```

## 2. 函数防抖

```ts
/** 函数防抖
 * [func 函数,wait 延迟执行毫秒数,immediate true 表立即执行,false 表非立即执行,立即执行是触发事件后函数会立即执行，然后n秒内不触发事件才能继续执行函数的效果]
 */
const debounce = function (func, wait, immediate) {
  let timeout: number | null = null;
  return function () {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      var callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
};
```

## 3. H5 软键盘缩回、弹起回调

```ts
/** H5软键盘缩回、弹起回调
 * 当软件键盘弹起会改变当前 window.innerHeight
 * 监听这个值变化 [downCb 当软键盘弹起后，缩回的回调,upCb 当软键盘弹起的回调]
 */
const h5Resize = (downCb: () => void, upCb: () => void) => {
  let clientHeight = window.innerHeight;
  downCb = typeof downCb === "function" ? downCb : () => {};
  upCb = typeof upCb === "function" ? upCb : () => {};

  const debounce = (func: () => void, wait: number) => {
    let timeout: number | null = null;
    return () => {
      if (timeout) clearTimeout(timeout);
      timeout = window.setTimeout(func, wait);
    };
  };

  window.addEventListener(
    "resize",
    debounce(() => {
      let height = window.innerHeight;
      if (height === clientHeight) {
        downCb();
      } else if (height < clientHeight) {
        upCb();
      }
    }, 100)
  );
};
```

## 4. 获取 url 参数

```ts
/** 获取url参数 */
const getUrlParam = function (name: string): string | undefined {
  const url = new URL(window.location.href);
  const params = new URLSearchParams(url.search);
  const paramValue = params.get(name);
  return paramValue ? decodeURIComponent(paramValue) : undefined;
};

/** url参数转对象 */
const parseQueryString = function (url?: string): Record<string, string> {
  const query: Record<string, string> = {};
  const urlString = url || window.location.href;
  const urlObj = new URL(urlString);
  const params = new URLSearchParams(urlObj.search);

  params.forEach((value, key) => {
    query[decodeURIComponent(key)] = decodeURIComponent(value);
  });

  return query;
};
```

## 5. 对象序列化

```ts
/** 对象序列化
 * [对象转url参数]
 */
const stringfyQueryString = (obj: Record<string, any>): string => {
  if (!obj) return "";
  const pairs: string[] = [];

  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        pairs.push(
          `${encodeURIComponent(key)}[${index}]=${encodeURIComponent(item)}`
        );
      });
    } else {
      pairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
    }
  });

  return pairs.join("&");
};
```

## 6. 浏览器是否支持 webP 格式图片

```ts
/** 浏览器是否支持webP格式图片*/
const isSupportWebP = (): boolean => {
  try {
    return (
      !![].map &&
      document
        .createElement("canvas")
        .toDataURL("image/webp")
        .indexOf("data:image/webp") === 0
    );
  } catch (e) {
    return false;
  }
};
```

## 7. base64 图片下载功能

```ts
/** base64图片下载功能 */
const base64ToBlob = (code: string): Blob => {
  const parts = code.split(";base64,");
  const contentType = parts[0].split(":")[1];
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);

  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }

  return new Blob([uInt8Array], { type: contentType });
};

const downloadFile = (base64: string, fileName: string): void => {
  const blob = base64ToBlob(base64);
  const aLink = document.createElement("a");
  const evt = new MouseEvent("click", {
    bubbles: true,
    cancelable: true,
    view: window,
  });

  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  aLink.dispatchEvent(evt);
};
```

## 8. 图片地址转 base64

```ts
/** 图片地址转base64*/
const getBase64 = (
  img: string,
  width?: number,
  height?: number
): Promise<string> => {
  const getBase64Image = (
    img: HTMLImageElement,
    width?: number,
    height?: number
  ): string => {
    const canvas = document.createElement("canvas");
    canvas.width = width || img.width;
    canvas.height = height || img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL();
  };

  return new Promise((resolve, reject) => {
    const image = new Image();
    image.crossOrigin = "Anonymous";
    image.src = img;

    image.onload = () => {
      resolve(getBase64Image(image, width, height));
    };

    image.onerror = (err) => {
      reject(err);
    };
  });
};
```

## 9. 光标所在位置插入字符

```ts
/** 光标所在位置插入字符 */
const insertAtCursor = (
  dom: HTMLInputElement | HTMLTextAreaElement,
  val: string
): void => {
  dom.focus();

  if (
    typeof dom.selectionStart === "number" &&
    typeof dom.selectionEnd === "number"
  ) {
    const startPos = dom.selectionStart;
    const endPos = dom.selectionEnd;
    const restoreTop = dom.scrollTop;

    dom.value =
      dom.value.substring(0, startPos) +
      val +
      dom.value.substring(endPos, dom.value.length);

    if (restoreTop > 0) {
      dom.scrollTop = restoreTop;
    }

    dom.selectionStart = dom.selectionEnd = startPos + val.length;
  } else {
    dom.value += val;
  }
};
```

## 10. 音频加载完成操作

```ts
/** 音频加载完成操作 */
const loadAudio = (src, callback) => {
  const audio = new Audio(src);
  audio.onloadedmetadata = callback;
};
```

## 11. 判断图片加载完成

```ts
/** 判断图片加载完成 */
const imgLoadAll = (arr, callback) => {
  const arrImg = [];
  const promises = arr.map((src) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        arrImg.push(img);
        resolve();
      };
      img.onerror = reject;
    });
  });

  Promise.all(promises)
    .then(() => {
      callback && callback();
    })
    .catch((error) => {
      console.error("图片加载失败:", error);
    });
};
```

## 12. 原生 dom 操作

```ts
/** 原生dom操作 */
const dom = {
  $: (selector) => {
    const type = selector.charAt(0);
    if (type === "#") {
      return document.querySelector(selector);
    } else if (type === ".") {
      return document.querySelectorAll(selector);
    } else {
      return document.querySelectorAll(selector);
    }
  },
  hasClass: (ele, name) => {
    /* 检测类名 */
    return new RegExp(`(\\s|^)${name}(\\s|$)`).test(ele.className);
  },
  addClass: (ele, name) => {
    /* 添加类名 */
    if (!dom.hasClass(ele, name)) ele.className += ` ${name}`;
  },
  removeClass: (ele, name) => {
    /* 删除类名 */
    if (dom.hasClass(ele, name)) {
      const reg = new RegExp(`(\\s|^)${name}(\\s|$)`);
      ele.className = ele.className.replace(reg, " ");
    }
  },
  replaceClass: (ele, newName, oldName) => {
    /* 替换类名 */
    dom.removeClass(ele, oldName);
    dom.addClass(ele, newName);
  },
  siblings: (ele) => {
    /* 获取兄弟节点 */
    const children = Array.from(ele.parentNode.children);
    return children.filter((child) => child !== ele);
  },
  getByStyle: (obj, name) => {
    /* 获取行间样式属性 */
    return window.getComputedStyle
      ? getComputedStyle(obj, false)[name]
      : obj.currentStyle[name];
  },
  domToString: (htmlDOM) => {
    /* DOM转字符串 */
    const div = document.createElement("div");
    div.appendChild(htmlDOM);
    return div.innerHTML;
  },
  stringToDom: (htmlString) => {
    /* 字符串转DOM */
    const div = document.createElement("div");
    div.innerHTML = htmlString;
    return div.children[0];
  },
};
```

## 13. 阿拉伯数字转中文大写数字

```ts
/** 阿拉伯数字转中文大写数字 */
const numberToChinese = (num) => {
  // 将阿拉伯数字翻译成中文的大写数字
  const AA = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];
  const BB = ["", "十", "百", "仟", "萬", "億", "点", ""];
  const a = ("" + num).replace(/(^0*)/g, "").split(".");
  let k = 0;
  let re = "";

  for (let i = a[0].length - 1; i >= 0; i--) {
    switch (k) {
      case 0:
        re = BB[7] + re;
        break;
      case 4:
        if (!new RegExp(`0{4}\\d{${a[0].length - i - 1}}$`).test(a[0])) {
          re = BB[4] + re;
        }
        break;
      case 8:
        re = BB[5] + re;
        BB[7] = BB[5];
        k = 0;
        break;
    }
    if (
      k % 4 === 2 &&
      a[0].charAt(i + 2) !== "0" &&
      a[0].charAt(i + 1) === "0"
    ) {
      re = AA[0] + re;
    }
    if (a[0].charAt(i) !== "0") {
      re = AA[a[0].charAt(i)] + BB[k % 4] + re;
    }
    k++;
  }

  if (a.length > 1) {
    // 加上小数部分(如果有小数部分)
    re += BB[6];
    for (let i = 0; i < a[1].length; i++) {
      re += AA[a[1].charAt(i)];
    }
  }

  if (re === "一十") {
    re = "十";
  }
  if (re.match(/^一/) && re.length === 3) {
    re = re.replace("一", "");
  }

  return re;
};
```

## 14. 生成随机数范围

```ts
/** 生成随机数范围 */
const random = (min, max) => {
  // 检查参数是否为数字
  if (typeof min !== "number" || typeof max !== "number") {
    return null;
  }

  // 生成随机数范围
  return Math.floor(min + Math.random() * (max + 1 - min));
};
```

## 15. 过滤 html 代码

```ts
const filterTag = (str) => {
  // 过滤html代码(把<>转换)
  return str
    .replace(/&/g, "&")
    .replace(/</g, "<")
    .replace(/>/g, ">")
    .replace(/ /g, " ");
};
```

## 16. 字符串大小写转换

```ts
/** 字符串大小写转换 */
const changeCase = (str, type = 4) => {
  switch (type) {
    case 1:
      return str.replace(
        /\b\w+\b/g,
        (word) =>
          `${word.charAt(0).toUpperCase()}${word.slice(1).toLowerCase()}`
      );
    case 2:
      return str.replace(
        /\b\w+\b/g,
        (word) =>
          `${word.charAt(0).toLowerCase()}${word.slice(1).toUpperCase()}`
      );
    case 3:
      return str
        .split("")
        .map((char) =>
          /[a-z]/.test(char) ? char.toUpperCase() : char.toLowerCase()
        )
        .join("");
    case 4:
      return str.toUpperCase();
    case 5:
      return str.toLowerCase();
    default:
      return str;
  }
};
```

## 17. 去除字符串空格

```ts
/** 去除字符串空格 */
const trim = (str, type = 1) => {
  switch (type) {
    case 1:
      return str.replace(/\s+/g, "");
    case 2:
      return str.replace(/^\s+|\s+$/g, "");
    case 3:
      return str.replace(/^\s+/g, "");
    case 4:
      return str.replace(/\s+$/g, "");
    default:
      return str;
  }
};
```

## 18. 是否为 PC 端

```ts
/** 是否为PC端 */
const isPC = () => {
  // 是否为PC端
  const userAgentInfo = navigator.userAgent;
  const Agents = [
    "Android",
    "iPhone",
    "SymbianOS",
    "Windows Phone",
    "iPad",
    "iPod",
  ];
  return !Agents.some((agent) => userAgentInfo.includes(agent));
};
```

## 19. 常用正则验证

```ts
/** 常用正则验证 */
const checkStr = (str, type) => {
  const patterns = {
    phone: /^1[3-9]\d{9}$/, // 手机号码
    tel: /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/, // 座机
    card: /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/, // 身份证
    pwd: /^[a-zA-Z]\w{5,17}$/, // 密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线
    postal: /[1-9]\d{5}(?!\d)/, // 邮政编码
    QQ: /^[1-9][0-9]{4,9}$/, // QQ号
    email: /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/, // 邮箱
    money: /^\d*(?:\.\d{0,2})?$/, // 金额(小数点2位)
    URL: /(http|ftp|https):\/\/[\w-_]+(\.[\w-_]+)+([\w-.,@?^=%&:/~+#]*[\w-@?^=%&/~+#])?/, // 网址
    IP: /((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))/, // IP
    date: /^(\d{4})-(\d{2})-(\d{2})( (\d{2})(?::\d{2}|:(\d{2}):(\d{2}))?)?$/, // 日期时间
    number: /^[0-9]$/, // 数字
    english: /^[a-zA-Z]+$/, // 英文
    chinese: /^[\u4E00-\u9FA5]+$/, // 中文
    lower: /^[a-z]+$/, // 小写
    upper: /^[A-Z]+$/, // 大写
    HTML: /<("[^"]*"|'[^']*'|[^'">])*>/, // HTML标记
  };

  return patterns[type] ? patterns[type].test(str) : true;
};
```

## 20. 时间与时间戳转换

```ts
/** 时间与时间戳转换 */
const stamp = {
  // 时间，时间戳转换
  getTime: (time = new Date()) => {
    // 时间转10位时间戳
    const date = new Date(time);
    return Math.round(date.getTime() / 1000);
  },
};
```

## 21. 判断两个数组是否相等

```ts
/** 判断两个数组是否相等 */
const arrayEqual = (arr1, arr2) => {
  // 判断两个数组是否相等
  if (arr1 === arr2) return true;
  if (arr1.length !== arr2.length) return false;
  return arr1.every((value, index) => value === arr2[index]);
};
```

## 22. 判断是否是一个数组

```ts
/** 判断是否是一个数组 */
const isArray = (arr) => Array.isArray(arr);
```

## 23. 文本复制功能

```ts
/** 文本复制功能 */
const copyTxt = (text, fn) => {
  // 复制功能
  if (typeof document.execCommand !== "function") {
    console.log("复制失败，请长按复制");
    return;
  }

  const dom = document.createElement("textarea");
  dom.value = text;
  dom.setAttribute("style", "display: block;width: 1px;height: 1px;");
  document.body.appendChild(dom);
  dom.select();

  const result = document.execCommand("copy");
  document.body.removeChild(dom);

  if (result) {
    console.log("复制成功");
    if (typeof fn === "function") fn();
    return;
  }

  if (typeof document.createRange !== "function") {
    console.log("复制失败，请长按复制");
    return;
  }

  const range = document.createRange();
  const div = document.createElement("div");
  div.innerHTML = text;
  div.setAttribute("style", "height: 1px;font-size: 1px;overflow: hidden;");
  document.body.appendChild(div);
  range.selectNode(div);

  const selection = window.getSelection();
  if (selection.rangeCount > 0) {
    selection.removeAllRanges();
  }
  selection.addRange(range);

  document.execCommand("copy");
  document.body.removeChild(div);

  if (typeof fn === "function") fn();
  console.log("复制成功");
};
```

## 24. 判断是否为微信

```ts
/** 判断是否为微信 */
const isWx = () => {
  // 判断是否为微信
  const ua = window.navigator.userAgent.toLowerCase();
  return ua.includes("micromessenger");
};
```

## 25. 用户设备判断 Mac|iPod|iPhone|iPad

```ts
/** 用户设备判断 Mac|iPod|iPhone|iPad */
const fetchRequest = (url, setting = {}) => {
  const opts = {
    method: (setting.method || "GET").toUpperCase(),
    headers: setting.headers || {},
    credentials:
      setting.credentials !== undefined ? setting.credentials : "include",
    body: setting.body || {},
    mode: setting.mode || "no-cors",
    redirect: setting.redirect || "follow",
    cache: setting.cache || "default",
  };

  const dataType = setting.dataType || "json";
  const data = setting.data || "";

  const paramsFormat = (obj) => new URLSearchParams(obj).toString();

  if (opts.method === "GET") {
    url = url + (data ? `?${paramsFormat(data)}` : "");
  } else {
    opts.body = JSON.stringify(data);
  }

  return new Promise((resolve, reject) => {
    fetch(url, opts)
      .then(async (res) => {
        let result;
        if (dataType === "text") {
          result = await res.text();
        } else if (dataType === "blob") {
          result = await res.blob();
        } else {
          result = await res.json();
        }
        resolve(result);
      })
      .catch((e) => {
        reject(e);
      });
  });
};
```

## 26. 原生 ajax 操作

```ts
/** 原生ajax操作 */
const ajax = (conf) => {
  const {
    url,
    data,
    async = true,
    type = "GET",
    dataType = "json",
    contentType = "application/x-www-form-urlencoded",
    success,
    error,
    isForm = false,
    header = {},
  } = conf;

  const paramsFormat = (obj) => new URLSearchParams(obj).toString();

  const fetchOptions = {
    method: type.toUpperCase(),
    headers: {
      "Content-Type": contentType,
      ...header,
    },
    credentials: "same-origin",
  };

  if (fetchOptions.method === "GET") {
    url += data ? `?${paramsFormat(data)}` : "";
  } else {
    fetchOptions.body = isForm ? data : paramsFormat(data);
  }

  fetch(url, fetchOptions)
    .then(async (response) => {
      if (!response.ok) {
        throw new Error(`通讯失败! ${response.status}`);
      }
      let result;
      if (dataType === "json") {
        result = await response.json();
      } else if (dataType === "text") {
        result = await response.text();
      } else if (dataType === "blob") {
        result = await response.blob();
      }
      if (success) success(result);
    })
    .catch((err) => {
      if (error) error(err.message);
    });
};
```

## 27. 时间格式化

```ts
/** 时间格式化 */ const formatDate = (fmt, date) => {
  // 时间格式化 【'yyyy-MM-dd hh:mm:ss',时间】
  if (typeof date !== "object") {
    date = !date ? new Date() : new Date(date);
  }

  const o = {
    "M+": date.getMonth() + 1, // 月份
    "d+": date.getDate(), // 日
    "h+": date.getHours(), // 小时
    "m+": date.getMinutes(), // 分
    "s+": date.getSeconds(), // 秒
    "q+": Math.floor((date.getMonth() + 3) / 3), // 季度
    S: date.getMilliseconds(), // 毫秒
  };

  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(
      RegExp.$1,
      (date.getFullYear() + "").substr(4 - RegExp.$1.length)
    );
  }

  for (const k in o) {
    if (new RegExp(`(${k})`).test(fmt)) {
      fmt = fmt.replace(
        RegExp.$1,
        RegExp.$1.length === 1 ? o[k] : `00${o[k]}`.substr(`${o[k]}`.length)
      );
    }
  }

  return fmt;
};
```

## 28. Js 获取元素样式【支持内联】

```ts
/** Js获取元素样式【支持内联】 */
const getRealStyle = (obj, styleName) => {
  if (obj.currentStyle) {
    return obj.currentStyle[styleName];
  } else if (window.getComputedStyle) {
    return window.getComputedStyle(obj, null)[styleName];
  }
  return null;
};
```

## 29. cookie 操作【set，get，del】

```ts
/** cookie操作【set，get，del】 */
const cookie = {
  set: function (name, value, day) {
    let oDate = new Date();
    oDate.setDatconst loadRes = (name, type) => {
  return new Promise((resolve, reject) => {
    let ref;
    if (type === "js") {
      // 外部js
      ref = document.createElement("script");
      ref.setAttribute("type", "text/javascript");
      ref.setAttribute("src", name);
    } else if (type === "css") {
      // 外部css
      ref = document.createElement("link");
      ref.setAttribute("rel", "stylesheet");
      ref.setAttribute("type", "text/css");
      ref.setAttribute("href", name);
    } else if (type === "style") {
      // style
      ref = document.createElement("style");
      ref.innerHTML = name;
    }

    if (ref) {
      document.getElementsByTagName("head")[0].appendChild(ref);
      ref.onload = () => resolve();
      ref.onerror = () => reject(new Error(`Failed to load resource: ${name}`));
    } else {
      reject(new Error(`Invalid resource type: ${type}`));
    }
  });
};

// 使用示例
loadRes('path/to/resource.js', 'js')
  .then(() => {
    console.log('Resource loaded successfully');
  })
  .catch((error) => {
    console.error(error);
  });   const data = localStorage.getItem(name);
    if (!data) {
      return null;
    }
    const obj = JSON.parse(data);
    if (new Date().getTime() > obj.time) {
      // 过期
      localStorage.removeItem(name);
      return null;
    } else {
      return obj.data;
    }
  },
  clear: (name) => {
    // 清空
    if (name) {
      // 删除键为name的缓存
      localStorage.removeItem(name);
    } else {
      // 清空全部
      localStorage.clear();
    }
  },
};
```

## 31. 加载 js || css || style

```ts
/** 加载 js || css || style */
const loadRes = function (name, type, fn) {
  // 加载js || css || style
  let ref;
  if (type === "js") {
    // 外部js
    ref = document.createElement("script");
    ref.setAttribute("type", "text/javascript");
    ref.setAttribute("src", name);
  } else if (type === "css") {
    // 外部css
    ref = document.createElement("link");
    ref.setAttribute("rel", "stylesheet");
    ref.setAttribute("type", "text/css");
    ref.setAttribute("href", name);
  } else if (type === "style") {
    // style
    ref = document.createElement("style");
    ref.innerhtml = name;
  }
  if (typeof ref !== "undefined") {
    document.getElementsByTagName("head")[0].appendChild(ref);
    ref.onload = function () {
      // 加载完成执行
      typeof fn === "function" && fn();
    };
  }
};
```

## 32. js 获取文件名后缀

1. 方式一：subtring()

```ts
/** 使用subtring() 截取字符串，对于文件名中会出现多个点的很有用，从最后一个点的地方截取。 */
const getSuffix = (name, includeDot = true) => {
  const lastIndex = name.lastIndexOf(".");
  if (lastIndex === -1) return ""; // 如果没有找到点，返回空字符串
  return includeDot ? name.substring(lastIndex) : name.substring(lastIndex + 1);
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

2. 方式二：正则

```ts
/** 使用正则，对只会出现一个点的适用： */
const getSuffix = (name, includeDot = true) => {
  const match = name.match(includeDot ? /.[^.]+$/ : /[^.]+$/);
  return match ? match[0] : "";
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

3. 方式三：转数组

```ts
const getSuffix = (name) => {
  const parts = name.split(".");
  return parts.length > 1 ? `.${parts.pop()}` : "";
};

// 使用示例
const fileName = "example.txt";
const suffix = getSuffix(fileName); // ".txt"

console.log(suffix); // 输出: .txt
```

4. 方式四：substr()

```ts
/** 同subtring()的字符串截取 */
const getSuffix = (name, includeDot = true) => {
  const lastIndex = name.lastIndexOf(".");
  if (lastIndex === -1) return ""; // 如果没有找到点，返回空字符串
  return includeDot ? name.substr(lastIndex) : name.substr(lastIndex + 1);
};

// 使用示例
const fileName = "example.txt";
const suffixWithDot = getSuffix(fileName); // ".txt"
const suffixWithoutDot = getSuffix(fileName, false); // "txt"

console.log(suffixWithDot); // 输出: .txt
console.log(suffixWithoutDot); // 输出: txt
```

## 33. 随机获取布尔值

```ts
/** 随机获取布尔值
 * Math.random() 输出 0 - 1 之间的随机数，然后判断这个随机数是否大于等于 0.5。这就说明有 50% 的机会得到真值或假值。
 */
const randomBoolean = (probability = 0.5) => Math.random() < probability;
// 使用示例
console.log(randomBoolean()); // 默认 50% 概率返回 true
console.log(randomBoolean(0.7)); // 70% 概率返回 true
console.log(randomBoolean(0.3)); // 30% 概率返回 true
```

## 34. 判断给的日期是工作日还是双休日

```ts
/** 判断给的日期是工作日还是双休日 */
const isWeekday = (date) => {
  if (!(date instanceof Date) || isNaN(date)) {
    throw new Error("Invalid date");
  }
  return date.getDay() % 6 !== 0;
};

// 使用示例
console.log(isWeekday(new Date(2021, 0, 11))); // 结果: true (Monday)
console.log(isWeekday(new Date(2021, 0, 10))); // 结果: false (Sunday)
```

## 35. 反转字符串

```ts
/** 反转字符串 */
const reverse = (str) => {
  if (typeof str !== "string") {
    throw new Error("Input must be a string");
  }
  return str.split("").reverse().join("");
};

// 使用示例
console.log(reverse("hello world")); // 结果: 'dlrow olleh'
```

## 36. 判断数字是偶数还是奇数

```ts
/** 判断数字是偶数还是奇数 */
const isEven = (num) => {
  if (typeof num !== "number") {
    throw new Error("Input must be a number");
  }
  return num % 2 === 0;
};

// 使用示例
console.log(isEven(2)); // 结果: true
console.log(isEven(3)); // 结果: false
console.log(isEven("4")); // 抛出错误: Input must be a number
```

## 37. 从日期获取当地时间

```ts
/** 从日期获取当地时间 */
const timeFromDate = (date) => {
  if (!(date instanceof Date) || isNaN(date)) {
    throw new Error("Invalid date");
  }
  return date.toTimeString().slice(0, 8);
};

// 使用示例
console.log(timeFromDate(new Date(2021, 0, 10, 17, 30, 0)));
// 结果: "17:30:00"
console.log(timeFromDate(new Date()));
// 结果: will log the current time
```

## 38. 使用 Math.pow()方法，将数字四舍五入到固定的小数点

```ts
/** 使用Math.pow()方法，将数字四舍五入到固定的小数点 */
const toFixed = (n, fixed) => {
  if (typeof n !== "number" || typeof fixed !== "number" || fixed < 0) {
    throw new Error("Invalid input");
  }
  return n.toFixed(fixed);
};

// Examples
console.log(toFixed(25.198726354, 1)); // 结果: "25.2"
console.log(toFixed(25.198726354, 2)); // 结果: "25.20"
console.log(toFixed(25.198726354, 3)); // 结果: "25.199"
console.log(toFixed(25.198726354, 4)); // 结果: "25.1987"
console.log(toFixed(25.198726354, 5)); // 结果: "25.19873"
console.log(toFixed(25.198726354, 6)); // 结果: "25.198726"
```

## 39. 使用 document.activeElement 属性，检查元素当前是否处于焦点

```ts
/** 使用 document.activeElement 属性，检查元素当前是否处于焦点 */
const elementIsInFocus = (el) => {
  if (!(el instanceof Element)) {
    throw new Error("Input must be a DOM element");
  }
  return el === document.activeElement;
};

// 使用示例
const anyElement = document.querySelector("input");
console.log(elementIsInFocus(anyElement)); // 结果: 如果元素在焦点中返回 true，否则返回 false
```

## 40. 获取所有参数平均值

```ts
/**  获取所有参数平均值 */
const average = (...args) => {
  if (args.length === 0) {
    throw new Error("At least one number is required");
  }
  if (!args.every((arg) => typeof arg === "number")) {
    throw new Error("All arguments must be numbers");
  }
  return args.reduce((a, b) => a + b, 0) / args.length;
};

// 使用示例
console.log(average(1, 2, 3, 4)); // 结果: 2.5
console.log(average(5, 10)); // 结果: 7.5
console.log(average()); // 抛出错误: At least one number is required
console.log(average(1, "2", 3)); // 抛出错误: All arguments must be numbers
```

## 41. 如何获取两个日期之间的天数间隔

```ts
const getDaysDiffBetweenDates = (dateInitial, dateFinal) => {
  if (
    !(dateInitial instanceof Date) ||
    isNaN(dateInitial) ||
    !(dateFinal instanceof Date) ||
    isNaN(dateFinal)
  ) {
    throw new Error("Both arguments must be valid Date objects");
  }
  const msPerDay = 1000 * 3600 * 24;
  return (dateFinal - dateInitial) / msPerDay;
};

// Example
console.log(
  getDaysDiffBetweenDates(new Date("2017-12-13"), new Date("2017-12-22"))
); // 结果: 9
```

## 42. 如何获得给定毫秒数的可读格式

```ts
/** 如何获得给定毫秒数的可读格式 */
const formatDuration = (ms, showMilliseconds = true) => {
  if (typeof ms !== "number" || isNaN(ms)) {
    throw new Error("Input must be a valid number");
  }
  if (ms < 0) ms = -ms;
  const time = {
    day: Math.floor(ms / 86400000),
    hour: Math.floor(ms / 3600000) % 24,
    minute: Math.floor(ms / 60000) % 60,
    second: Math.floor(ms / 1000) % 60,
    millisecond: Math.floor(ms) % 1000,
  };
  return Object.entries(time)
    .filter(
      ([key, val]) => val !== 0 && (showMilliseconds || key !== "millisecond")
    )
    .map(([key, val]) => `${val} ${key}${val !== 1 ? "s" : ""}`)
    .join(", ");
};

// Examples
console.log(formatDuration(1001)); // 结果: "1 second, 1 millisecond"
console.log(formatDuration(34325055574)); // 结果: "397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds"
console.log(formatDuration(34325055574, false)); // 结果: "397 days, 6 hours, 44 minutes, 15 seconds"
```

## 43. 如何确定页面的浏览器选项卡是否处于前台活跃状态

```ts
/** 如何确定页面的浏览器选项卡是否处于前台活跃状态 */
const isBrowserTabFocused = () => {
  if (typeof document === "undefined") {
    throw new Error("This function can only be run in a browser environment");
  }
  return !document.hidden;
};

// Example
console.log(isBrowserTabFocused()); // 结果: true 或 false，取决于浏览器标签是否在焦点中
```

## 44. 按比例缩放二维向量（宽度和高度），使其最大尺寸不超过指定的限制

```ts
/** 按比例缩放二维向量（宽度和高度），使其最大尺寸不超过指定的限制 */
type Vector2 = import("@use-gesture/react").Vector2;

const MAX_LIMIT = 800;
export const scaleSize = (
  size: Vector2,
  limit: number = MAX_LIMIT
): Vector2 => {
  const max = Math.max(...size);
  if (max <= limit) {
    return size;
  }
  if (size[0] > size[1]) {
    const scale = limit / size[0];
    return [limit, size[1] * scale];
  }
  const scale = limit / size[1];
  return [size[0] * scale, limit];
};
```

## 45. 保存图片图像

```ts
/** 保存图片图像
 * 该方法首先检查背景 URL 是否以 'image://' 开头，如果是则直接返回。否则，它会获取图像数据，将其编码为 Base64 字符串并保存。如果保存失败，则抛出错误；如果成功，则返回并设置背景图像。
 * tw.widget.saveImage() 方法用于保存图像数据，它接受一个对象作为参数，该对象包含图像数据的 Base64 字符串。如果保存成功，则返回一个包含图像 URL 的对象；否则返回一个空对象。
 */
import { Base64 } from "js-base64";

async function saveBackground() {
  if (this.backgroundUrl?.startsWith("image://")) {
    return this.backgroundUrl;
  }
  const buffer = await fetch(this.backgroundUrl!).then((res) =>
    res.arrayBuffer()
  );
  const result = await tw.widget.saveImage({
    data: Base64.fromUint8Array(new Uint8Array(buffer)),
  });
  if (!result.value) {
    throw new Error("Save Background Image Failed");
  }
  return (this.background = result.value);
}
```

## 46. 返回一个 Promise，并在指定的毫秒数 (ms) 后解决(resolve)

```ts
/** 返回一个 Promise，并在指定的毫秒数 (ms) 后解决（resolve) */
export const sleep = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

async function example() {
  console.log("等待 2 秒...");
  await sleep(2000);
  console.log("2 秒后");
}

example();
```

## 47. 获取指定路径的字符串内容，并将其缓存以提高后续访问的效率

```ts
/** 获取指定路径的字符串内容，并将其缓存以提高后续访问的效率
 * 处理带有命名空间的本地存储操作。它提供了设置、获取、删除单个项以及删除所有项的方法。
 */
import { BUNDLE_ID } from "@/env";

declare class LocalStorage<
  T extends Record<string, unknown> = Record<string, unknown>
> {
  constructor(namespace: string);

  setItem<K extends keyof T, V = T[K]>(key: K, value: V): Promise<0>;

  getItem<K extends keyof T, V = T[K]>(key: K): Promise<V | null>;

  removeItem<K extends keyof T>(key: K): Promise<0>;

  removeAll(): Promise<0>;
}

const storage = new LocalStorage(BUNDLE_ID);

export default storage;

const PATH_STRING_CACHE = new Map<string, string>();

export const getPathString = async (path: string): Promise<string | null> => {
  if (PATH_STRING_CACHE.has(path)) {
    return PATH_STRING_CACHE.get(path) as string;
  }
  const cache = await storage.getItem<string, string | null>(`PATH_${path}`);
  if (cache) {
    PATH_STRING_CACHE.set(path, cache!);
    return cache!;
  }
  const res = await fetch(path);
  const pathString = await res.text();
  PATH_STRING_CACHE.set(path, pathString);
  storage.setItem(`PATH_${path}`, pathString);
  return pathString;
};
```

## 48. 计算一个矩形在另一个矩形内完全覆盖时的尺寸和位置

```ts
/** 计算一个矩形在另一个矩形内完全覆盖时的尺寸和位置
 * 确保一个矩形在另一个矩形内完全覆盖，并且居中显示。
 */
type Vector2 = import("@use-gesture/react").Vector2;

export const getCoveredRect = (size: Vector2, boundedSize: Vector2) => {
  const [width, height] = size;
  const [boundedWidth, boundedHeight] = boundedSize;
  const ratio = Math.max(boundedWidth / width, boundedHeight / height);
  const coveredWidth = width * ratio;
  const coveredHeight = height * ratio;
  return {
    width: coveredWidth,
    height: coveredHeight,
    x: (boundedWidth - coveredWidth) / 2,
    y: (boundedHeight - coveredHeight) / 2,
  };
};
```

## 49. 加载图像

```ts
/** 加载图像
 * 创建一个新的图像对象并设置其 src 属性来加载图像。它返回一个 Promise，当图像成功加载时，Promise 会被解析并返回图像对象；如果加载失败，Promise 会被拒绝。
 */

export const loadImage = (url: string) => {
  return new Promise<HTMLImageElement>((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
};
```

## 50. 将角度转换为弧度

```ts
/** 将角度转换为弧度 */
export const angle2radian = (angle: number) => (angle * Math.PI) / 180;
```

## 51. 将输入字符串的第一个字符转换为大写，其余字符转换为小写

```ts
/** 将输入字符串的第一个字符转换为大写，其余字符转换为小写 */
export const uppercase = (s: string) => {
  const [f, ...r] = s;
  return `${f.toUpperCase()}${r.join("").toLowerCase()}`;
};
```

## 52. 借用一定数量的 canvas 元素。如果请求的数量超过 12，则抛出错误。否则，它会确保 CACHED_CANVAS 数组中有足够的 canvas 元素，并返回前 count 个 canvas 元素

```ts
/** 借用一定数量的 canvas 元素。如果请求的数量超过 12，则抛出错误。否则，它会确保 CACHED_CANVAS 数组中有足够的 canvas 元素，并返回前 count 个 canvas 元素 */

const CACHED_CANVAS: HTMLCanvasElement[] = [];
export const borrowCanvas = (count: number) => {
  if (count > 12) {
    throw new Error("Maximum canvas count is 12");
  }
  while (CACHED_CANVAS.length < count) {
    CACHED_CANVAS.push(document.createElement("canvas"));
  }
  return CACHED_CANVAS.slice(0, count);
};
```

## 53. 判断一个角度 angle 是否在目标角度 target 的阈值 threshold 范围内

```ts
/** 判断一个角度 angle 是否在目标角度 target 的阈值 threshold 范围内 */
export const resetReactive = <T>(obj: any) => {
  Object.keys(obj).forEach((key) => {
    delete obj[key];
  });
};
const obj = { a: 1, b: 2, c: 3 };
resetReactive(obj);
console.log(obj); // 输出: {}
```

## 54. 清空传入对象的所有属性

```ts
/** 清空传入对象的所有属性 */
export const resetReactive = <T>(obj: any) => {
  Object.keys(obj).forEach((key) => {
    delete obj[key];
  });
};
const obj = { a: 1, b: 2, c: 3 };
resetReactive(obj);
console.log(obj); // 输出: {}
```

## 55. 显示一个警告对话框，提示用户有未保存的更改，并根据用户的选择返回一个 Promis

```ts
/** 显示一个警告对话框，提示用户有未保存的更改，并根据用户的选择返回一个 Promis */

export const alertUnsavedChanges = () => {
  return new Promise<void>((resolve, reject) => {
    // 弹出对话框，别的项目使用需要更换
    tw.showAlert(
      {
        title: "未保存更改",
        message: "你的更改还未保存，确定要返回吗？",
        style: 1,
        actions: [
          { title: "取消", id: 0, style: 1 },
          { title: "确定", id: 1, style: 0 },
        ],
      },
      (id: number) => {
        if (id === 1) {
          resolve();
          return;
        }
        reject();
      }
    );
  });
};
```

## 56. 用于获取图像的元数据（宽度和高度）

```ts
/** 用于获取图像的元数据（宽度和高度）
 * 通过加载图像来获取其宽度和高度，并返回一个包含这些信息的 Promise。
 */

interface ImageMetadata {
  width: number;
  height: number;
}
export const getImageMetadata = (url: string) => {
  return new Promise<ImageMetadata>((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve({ width: img.width, height: img.height });
    img.onerror = reject;
    img.src = url;
  });
};
```

## 57. 压缩图像，使其尺寸不超过指定的最大宽度和高度

```ts
/** 压缩图像，使其尺寸不超过指定的最大宽度和高度 */
type Vector2 = import("@use-gesture/react").Vector2;
const COMPRESS_CANVAS = document.createElement("canvas");
const COMPRESS_CONTEXT = COMPRESS_CANVAS.getContext("2d")!;
export const compressImage = (url: string, maximum: Vector2 = [2000, 2000]) => {
  return new Promise<string>((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const [width, height] = [img.width, img.height];
      const [maxWidth, maxHeight] = maximum;
      const ratio = Math.min(maxWidth / width, maxHeight / height);
      COMPRESS_CONTEXT.clearRect(
        0,
        0,
        COMPRESS_CANVAS.width,
        COMPRESS_CANVAS.height
      );
      COMPRESS_CANVAS.width = width * ratio;
      COMPRESS_CANVAS.height = height * ratio;
      COMPRESS_CONTEXT.drawImage(img, 0, 0, width * ratio, height * ratio);
      COMPRESS_CANVAS.toBlob(
        (blob) => {
          const reader = new FileReader();
          reader.onload = () => {
            resolve(reader.result as string);
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob!);
        },
        "image/png",
        1
      );
    };
    img.onerror = reject;
    img.src = url;
  });
};
```

## 58. 版本控制

```ts
/**
 * compare two version and return the greater one
 * @example
 * compare('1.0.0', '0.1.1') => 0
 * compare('1.0.0', '1.0.0') => -1
 * compare('1.0', '1.1.1') => 1
 */
export function compare(v1: string, v2: string): 0 | 1 | -1 {
  const vArr1 = v1.split(".").map((item) => +item.trim());
  const vArr2 = v2.split(".").map((item) => +item.trim());
  while (vArr1.length > vArr2.length) {
    vArr2.push(0);
  }
  while (vArr1.length < vArr2.length) {
    vArr1.push(0);
  }
  for (let i = 0; i < vArr1.length; i++) {
    if (vArr1[i] > vArr2[i]) {
      return 0;
    }
    if (vArr1[i] < vArr2[i]) {
      return 1;
    }
  }
  return -1;
}

/**
 * v1 is lesser than v2
 * v1 小于 v2
 */
export const lt = (v1: string, v2: string) => compare(v1, v2) === 1;
/**
 * v1 is greater than v2
 * v1 大于 v2
 */
export const gt = (v1: string, v2: string) => compare(v1, v2) === 0;
/**
 * v1 is equal to v2
 * v1 等于 v2
 */
export const e = (v1: string, v2: string) => compare(v1, v2) === -1;
/**
 * v1 is greater than or equal to v2
 * v1 大于等于 v2
 */
export const gte = (v1: string, v2: string) => compare(v1, v2) !== 1;
/**
 * v1 is lesser than or equal to v2
 * v1 小于等于 v2
 */
export const lte = (v1: string, v2: string) => compare(v1, v2) !== 0;
```

## 59. 复制文本到剪贴板

```ts
const copyToClipboard = (text) => navigator.clipboard.writeText(text);

copyToClipboard("Hello, World!")
  .then(() => {
    console.log("Text copied to clipboard");
  })
  .catch((err) => {
    console.error("Failed to copy text: ", err);
  });
```

## 60. 横向滚动点击后居中

```html
<div class="" ref="scrollRef">
  <div
    key="{index}"
    className="w-40 h-40 bg-$secondaryButton flex
      items-center justify-center rounded-10 relative"
    onClick="moveCenter(e)"
  ></div>
</div>
```

```ts
const moveBox = (el: HTMLDivElement) => {
  // scrollRef.current 是滚动容器的 ref
  if (!scrollRef.current) return;
  const { left: targetX, width: targetW } = el.getBoundingClientRect();
  const scrollX = scrollRef.current.scrollLeft;
  const scrollW = scrollRef.current.getBoundingClientRect().width;
  const offset = targetX - scrollW / 2;
  scrollRef.current?.scrollTo({
    left: scrollX + offset + targetW / 2,
    behavior: "smooth",
  });
};

const moveCenter = (e) => {
  moveBox(e.currentTarget as HTMLDivElement);
};
```

## 61. 获取某个日期是当年的第几天

```ts
const dayOfYear = (date) => {
  return Math.floor(
    (date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24
  );
};

const text = dayOfYear(new Date(2020, 10, 27)); // 332
const text1 = dayOfYear(new Date());
console.log(text, text1);
```

## 62. 将图片转换为 Base64 编码的字符串

```ts
export function convertImageToBase64(
  url: string,
  clean = true
): Promise<string> {
  return new Promise((resolve, reject) => {
    url = url.replace(
      "top-widgets-oss-cdn.topwidgets.com",
      "top-widgets.oss-cn-shenzhen.aliyuncs.com"
    );
    url = url.replace(
      "storm-oss-cdn.topwidgets.com",
      "resource.topwidgets.com"
    );
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = function () {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx!.drawImage(img, 0, 0);
      const base64 = canvas.toDataURL("image/png");
      resolve(clean ? cleanBase64(base64) : base64);
    };
    img.onerror = reject;
    img.src = url;
  });
}
export const cleanBase64 = (str: string) => {
  return str.replace(/^data:image\/(png|jpg|jpeg);base64,/, "");
};
```

## 63. 将 rgb 颜色灰度化

```ts
const gray = (r, g, b) => 0.2126 * r + 0.7152 * g + 0.0722 * b;

console.log(gray(50, 100, 150)); // 92.9777777777777...
```

## 64. 解析 url 中的参数

```ts
const parseQuery = (url) => {
  q = {};
  url.replace(/([^?&=]+)=([^&]+)/g, (_, k, v) => (q[k] = v));
  return q;
};

const text1 = parseQuery("https://www.baidu.com/s?wd=js&name=hello"); // { wd: 'js', name: 'hello' }
const text2 = parseQuery("a=1&b=2"); // { a: '1', b: '2' }
console.log(text1);
console.log(text2);
```

## 65. 判断是否是数字

```ts
export const isNumberString = (v: string = "") => /^\d+$/.test(v);
```

## 66. 去掉字符串中的元素标记

```ts
const removeTag = (fragment) => {
  return (
    new DOMParser().parseFromString(fragment, "text/html").body.textContent ||
    ""
  );
};

const text = removeTag(`<div>Hello World</div>`);
console.log(text); // Hello World
```

## 67. 筛选对象属性

```ts
const pick = (obj, ...props) => {
  return Object.fromEntries(
    Object.entries(obj).filter(([k]) => props.includes(k))
  );
};

const text = pick({ a: 1, b: 2, c: 3 }, "a", "c"); // { a: 1, c: 3 }
console.log(text);
```

## 68. 生成一个随机字符串

```ts
const randomString = () => Math.random().toString(36).slice(2);

const text = randomString();
const text1 = randomString();
console.log(text, text1);
```

## 69. 随机 HEX 颜色

```ts
const randomColor = () => {
  return (
    "#" +
    Math.floor(Math.random() * 0xffffff)
      .toString(16)
      .padEnd(6, "0")
  );
};

const text1 = randomColor();
const text2 = randomColor();
const text3 = randomColor();
console.log(text1, text2, text3);
```

## 70. 压缩图片宽度

```ts
export function compressImageByWidth(
  url: string,
  maxWidth: number,
  quality: number
): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function () {
      const canvas = document.createElement("canvas");
      let width = img.width;
      let height = img.height;
      if (width > maxWidth) {
        height *= maxWidth / width;
        width = maxWidth;
      }
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx!.drawImage(img, 0, 0, width, height);
      const base64 = canvas.toDataURL("image/png");
      resolve(base64);
    };
    img.onerror = reject;
    img.src = url;
  });
}
```

## 71. ipad 方法

```ts
export const onOrientationChange = (callback: () => void) => {
  const mql = window.matchMedia("(orientation: portrait)");
  mql.addEventListener("change", () => {
    callback();
  });
};
export function getOrientation() {
  const isLandscape = window.matchMedia("(orientation: landscape)").matches;
  return isLandscape ? "landscape" : "portrait";
}
export const getRealWidthAndHeight = () => {
  const orientation = getOrientation();
  if (orientation === "landscape") {
    const width = Math.max(window.screen.width, window.screen.height);
    const height = Math.min(window.screen.width, window.screen.height);
    return {
      width,
      height,
    };
  } else {
    const width = Math.min(window.screen.width, window.screen.height);
    const height = Math.max(window.screen.width, window.screen.height);
    return {
      width,
      height,
    };
  }
};
```

## 72. Promise 解决接口超时

1. 方式一：

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  // 假设请求需要 1s
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return new Promise((resolve, reject) => {
    const promises = [requestFn(), sleep(delay)];
    for (const promise of promises) {
      // 超时则执行失败，不超时则执行成功
      promise.then(
        (res) => resolve(res),
        (err) => reject(err)
      );
    }
  });
}

// 超时
timeoutPromise(request, 500).catch((err) => console.log(err)); // 接口超时

// 不超时
timeoutPromise(request, 2000).then((res) => console.log(res)); // 接口成功
```

2. 方式二: promise.race

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  // 假设请求需要 1s
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
// promise.race可以代替手写的超时判断
function timeoutPromise(requestFn, delay) {
  // 如果先返回的是延迟Promise则说明超时了
  // race会直接返回最先执行完的Promise
  return Promise.race([requestFn(), sleep(delay)]);
}

// 超时
timeoutPromise(request, 500).catch((err) => console.log(err)); // 接口超时

// 不超时
timeoutPromise(request, 2000).then((res) => console.log(res)); // 接口成功
```

## 73. Promise 解决转盘问题

1. 方式一: 转盘转动完成前数据就回来了

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 模拟转盘旋转到停止的延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function turntableSleep(delay) {
  return new Promise((resolve) => {
    setTimeout(() => resolve("转盘停止转动"), delay);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return Promise.race([requestFn(), sleep(delay)]);
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} turntableDelay 转盘转多久
 * @param {number} delay 请求超时时长
 * @returns {Promise<any>}
 */

function turntablePromise(requestFn, turntableDelay, delay) {
  return Promise.all([
    timeoutPromise(requestFn, delay),
    turntableSleep(turntableDelay),
  ]);
}

// 不超时，且先于转盘停止前请求回数据
turntablePromise(request, 2500, 1500).then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

2. 方式二: 转盘转动完成数据未回来

```ts
/**
 * 模拟延时
 * @param {number} delay 延迟时间
 * @returns {Promise<any>}
 */
function sleep(delay) {
  return new Promise((_, reject) => {
    setTimeout(() => reject("接口超时"), delay);
  });
}

/**
 * 模拟请求
 */
function request() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("接口成功"), 1000);
  });
}

/**
 * 判断是否超时
 * @param {() => Promise<any>} requestFn 请求函数
 * @param {number} delay 延迟时长
 * @returns {Promise<any>}
 */
function timeoutPromise(requestFn, delay) {
  return Promise.race([requestFn(), sleep(delay)]);
}

// 不超时，且先于转盘停止前请求回数据
timeoutPromise(request, 2500, 1500).then(
  (res) => console.log(res),
  (err) => console.log(err)
);
```

## 74. Promise 控制并发接口

```ts
/** Promise控制并发(如果需要一次性发送过多请求，可以使用Promise控制并发， 先发送一部分请求，等这一部分请求完成后再发送下一部分请求)
 * 1. 限制并发数
 * 2. 任务完成后，返回结果
 * 3. 任务失败后，返回失败原因
 * 4. 任务完成后，继续添加任务
 * 5. 任务失败后，继续添加任务
 */
class Scheduler {
  constructor(limit) {
    this.dataList = [];
    // 限制并发数
    this.limit = limit;
    this.count = 0;
  }

  // 添加任务的方法
  add(time, order) {
    const promiseCreator = () => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(order);
          resolve();
        }, time);
      });
    };
    this.dataList.push(promiseCreator);
  }

  taskStart() {
    for (let i = 0; i < this.limit; i++) {
      this.request();
    }
  }

  request() {
    if (!this.dataList.length || this.count >= this.limit) return;
    this.count++;
    this.dataList
      .shift()()
      .then(() => {
        this.count--;
        this.request();
      });
  }
}

// 测试
const scheduler = new Scheduler(2);
const addTask = (time, order) => {
  scheduler.add(time, order);
};
addTask(1000, "1");
addTask(500, "2");
addTask(300, "3");
addTask(400, "4");
scheduler.taskStart();
```

## 75. Promise 取消重复请求

```ts
/** 取消重复请求
 * 1. 保证只有一个请求在执行
 * 2. 如果有新请求，取消之前的请求
 * 3. 如果请求已经完成，不会取消
 * 4. 如果请求已经取消，不会执行回调
 * 5. 如果请求失败，不会执行回调
 * 6. 如果请求成功，执行回调
 * 7. 如果请求被取消，执行回调
 * 8. 如果请求被取消，不会执行回调
 */

class CancelablePromise {
  constructor() {
    this.pendingPromise = null;
    this.reject = null;
  }

  request(requestFn) {
    if (this.pendingPromise) {
      this.cancel("取消重复请求");
    }

    const promise = new Promise((_, reject) => (this.reject = reject));
    this.pendingPromise = Promise.race([requestFn(), promise]);
    return this.pendingPromise;
  }

  cancel(reason) {
    this.reject(reason);
    this.pendingPromise = null;
  }
}

function request(delay) {
  return () =>
    new Promise((resolve) => {
      setTimeout(() => {
        resolve("最后赢家是我");
      }, delay);
    });
}

const cancelPromise = new CancelablePromise();

// 模拟频繁请求5次
for (let i = 0; i < 5; i++) {
  cancelPromise
    .request(request(2000))
    .then((res) => console.log(res)) // 最后一个 最后赢家是我
    .catch((err) => console.error(err)); // 前四个 取消重复请求
}
```

## 76. Promise 全局请求 loading

```ts
/** promise全局请求loading
 * 全局只要有一个接口还在请求中就展示loading
 * 全局所有接口请求完后隐藏loading
 */

class PromiseManager {
  constructor() {
    this.pendingPromise = new Set();
    this.loading = false;
  }

  generateKey() {
    return `${new Date().getTime()}-${parseInt(Math.random() * 1000)}`;
  }

  push(...requestFns) {
    for (const requestFn of requestFns) {
      const key = this.generateKey();
      this.pendingPromise.add(key);
      requestFn().finally(() => {
        this.pendingPromise.delete(key);
        this.loading = this.pendingPromise.size !== 0;
      });
    }
  }
}

// 模拟请求
function request(delay) {
  return () => {
    return new Promise((resolve) => {
      setTimeout(() => resolve("成功喽"), delay);
    });
  };
}

const manager = new PromiseManager();

manager.push(
  request(1000),
  request(2000),
  request(800),
  request(2000),
  request(1500)
);

const timer = setInterval(() => {
  // 轮询查看loading状态
  console.log(manager.loading);
}, 300);
```

## 77. 操作 dom Class

```ts
// 检查元素是否包含指定的CSS类
function hasClass(elem: Element, cls = "") {
  if (cls.replace(/\s/g, "").length === 0) return false; //当cls没有参数时，返回false
  return new RegExp(" " + cls + " ").test(" " + elem.className + " ");
}

// 添加指定的CSS类
function addClass(elem: Element, cls: string) {
  if (!hasClass(elem, cls)) {
    elem.className = elem.className === "" ? cls : elem.className + " " + cls;
  }
}

// 删除指定的CSS类
function removeClass(elem: Element, cls: string) {
  if (hasClass(elem, cls)) {
    let newClass = " " + elem.className.replace(/[\t\r\n]/g, "") + " ";
    while (newClass.indexOf(" " + cls + " ") >= 0) {
      newClass = newClass.replace(" " + cls + " ", " ");
    }
    elem.className = newClass.replace(/^\s+|\s+$/g, "");
  }
}

export { addClass, removeClass };
```

## 78. 计算一个数字数组的标准差（Standard Deviation, SD）和平均值（mean）

```ts
/** 该函数返回一个对象，包含两个属性：SD（标准差）和 mean（平均值）。 */
export const calculateSD = (arr: number[]) => {
  const n = arr.length;
  const mean = arr.reduce((a, b) => a + b, 0) / n;
  return {
    SD: Math.sqrt(
      arr.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n
    ),
    mean,
  };
};
```

## 79. 
